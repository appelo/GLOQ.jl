var documenterSearchIndex = {"docs":
[{"location":"example2/#Example-2:-characterization-of-single-qubit-Ramsey-experiment,-Echo-experiment-and-T1-decay-experiment.","page":"Example 2","title":"Example 2: characterization of single qubit Ramsey experiment, Echo experiment and T1-decay experiment.","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"In this example, we solve a single qubit characterization problem based on the synthetic data of a  Ramsey experiment, an Echo experiment and a T1-decay experiment. We seek the relaxation time T_1=1gamma_1, the dephasing time T_2=1gamma_2 and the transition frequency omega_01. We first consider the synthetic data without noise. The code can be ran by cd(\"examples\");include(\"SingleQubitBayesian.jl\"). ","category":"page"},{"location":"example2/#Step-1:-generate-the-synthetic-data","page":"Example 2","title":"Step 1: generate the synthetic data","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Set up system parameters and the initial state vectors.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# System parameters for a simple two level open quantum system\nN_states = 2; # number of states\nfreqs = [4.1] # transition frequency in GHz\nomegas = 2.0*pi.*freqs # change to angular frequency\ngamma1   = [1.0/(45.0*GLOQ.GLOQ_MICRO_SEC)] # Reciprocal of relaxation time - T1 (in units of ns)\ngamma2   = [1.0/(24.0*GLOQ.GLOQ_MICRO_SEC)] # Reciprocal of dephasing time - T2 (in units of ns)\nomr_ramsey = 2.0*pi*(4.1 - 5.0e-4) # drive frequency for the Ramsey experiment\nomr_echo = 2.0*pi*4.1  # drive frequency for the Echo experiment\nomr_t1 = 2.0*pi*4.1  # drive frequency for the T1 experiment\nTC = 2.5*17.0 # total control time\n\n# Initial state\ninitial_state = 0\nstate_u0 = [0.0;0.0]\nstate_v0 = [0.0;0.0]\nstate_u0[initial_state+1] = 1.0\n","category":"page"},{"location":"example2/#Forward-solve-to-generate-synthetic-data","page":"Example 2","title":"Forward solve to generate synthetic data","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Set up the duration and dark time samples of the Ramsey experiment.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# Forward solve to generate synthetic data for the Ramsey experiment\n# Duration of the Ramsey experiment, largest dark time\nT_Ramsey = 10.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_ramsey = 201\n# Step size of the Ramsey experiment\ndt_ramsey = T_Ramsey/N_dark_ramsey\nt_dark_ramsey = collect(range(0.0, T_Ramsey, length=N_dark_ramsey))","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Generate the synthetic data of the Ramsey experiment with GLOQ.RamseyForwardSolve.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# Forward solve\nrho_synthetic_ramsey_u,rho_synthetic_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t state_u0,state_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr_ramsey, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_ramsey,N_states) # control time, dark time, total number of states\npopulation_ramsey_synthetic = GLOQ.get_population(rho_synthetic_ramsey_u)","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Set up the duration and dark time samples of the Echo experiment.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# Echo experiment\n# Duration of the Echo experiment, largest dark time\nT_Echo = 30.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_echo = 601\n# Step size of the Echo experiment\ndt_echo = T_Echo/N_dark_echo","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Generate the synthetic data of the Echo experiment with GLOQ.EchoForwardSolve.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"rho_synthetic_echo_u,rho_synthetic_echo_v = GLOQ.EchoForwardSolve(\n\t\t\t\t state_u0,state_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr_echo, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_echo,N_states) # control time, dark time, total number of states\npopulation_echo_synthetic = GLOQ.get_population(rho_synthetic_echo_u)","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Set up the  the T1 experiment.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# T1\n# Duration of the T1-decay experiment, largest dark time\nT_t1 = 40.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_t1 = 401\n# Step size of the T1 experiment\ndt_t1 = T_t1/N_dark_t1\nt_dark_t1 = collect(range(0.0, T_t1, length=N_dark_t1))","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Generate the synthetic data of the T1 experiment with GLOQ.T1ForwardSolve.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"rho_synthetic_t1_u,rho_synthetic_t1_v = GLOQ.T1ForwardSolve(\n\t\t\t\t state_u0,state_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr_t1, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_t1,N_states) # control time, dark time, total number of states\npopulation_t1_synthetic = GLOQ.get_population(rho_synthetic_t1_u)\n","category":"page"},{"location":"example2/#Step-2:-define-the-objective-function,-initial-guess-and-optimization-bounds","page":"Example 2","title":"Step 2: define the objective function, initial guess and optimization bounds","text":"","category":"section"},{"location":"example2/#Step-2a:-define-the-objective-function.-Here,-we-use-the-normalized-l2-mismatch.","page":"Example 2","title":"Step 2a: define the objective function. Here, we use the normalized l2-mismatch.","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Suppose the number of dark times in the Ramsey experiment to be N_textrmDark. The objective function is defined as ","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"beginalign*\n\t Delta t_textrmRamseybigbig textrmForward Solve Ramsey Results-textrmSynthetic Ramsey Databigbig_2^2\n\t+Delta t_textrmEchobigbig textrmForward Solve Echo Results-textrmSynthetic Echo Databigbig_2^2\n\t+Delta t_T_1bigbig textrmForward Solve T1-decay Results-textrmSynthetic T1-decay Databigbig_2^2\nendalign*","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"with cdot_2 being the l_2-norm, Delta t_textrmRamsey is the time step size of the Ramsey experiment, Delta t_textrmEcho is the time step size of the Echo experiment, and Delta t_T_1 is the time step size of the T_1-decay experiment.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# Define the loss function for the GalacticOptim\n# p: phyiscal parameters:\n#\t p[1] = transition frequency in GHz\n#    p[2] = gamma1\n#    p[3] = gamma2\n# dummy_parameter: needed by GalacticOptim, one can just put [] here\nfunction loss(p,dummy_parameter)\n\t# Ramsey\n\t_rho_ramsey_u,_rho_ramsey_v = GLOQ.RamseyForwardSolve(state_u0,state_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_ramsey,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_ramsey,N_states)\n\t_population_ramsey = GLOQ.get_population(_rho_ramsey_u)\n\t# Echo\n    _rho_echo_u,_rho_echo_v = GLOQ.EchoForwardSolve(state_u0,state_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_echo,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_echo,N_states)\n\t_population_echo = GLOQ.get_population(_rho_echo_u)\n\t# T1\n    _rho_t1_u,_rho_t1_v = GLOQ.T1ForwardSolve(state_u0,state_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_t1,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_t1,N_states)\n\t_population_t1 = GLOQ.get_population(_rho_t1_u)\n\n\t_loss = sum(abs2,_population_ramsey-population_ramsey_synthetic)*dt_ramsey+\n\t\t\tsum(abs2,_population_echo-population_echo_synthetic)*dt_echo+\n\t\t\tsum(abs2,_population_t1-population_t1_synthetic)*dt_t1\n\t\t\n\treturn _loss\nend\n","category":"page"},{"location":"example2/#Step-2b:-define-a-callback-function-to-plot-while-optimizing","page":"Example 2","title":"Step 2b: define a callback function to plot while optimizing","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"plot_callback = function(p,other_args)\n\t# Ramsey\n\trho_ramsey_u,rho_ramsey_v = GLOQ.RamseyForwardSolve(state_u0,state_v0,\n\t\t\t\t\t (2*pi).*[p[1]],omr_ramsey,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\tpopulation_ramsey = GLOQ.get_population(rho_ramsey_u)\n\t# Echo\n    rho_echo_u,rho_echo_v = GLOQ.EchoForwardSolve(state_u0,state_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_echo,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\tpopulation_echo = GLOQ.get_population(rho_echo_u)\n\t# T1\n    rho_t1_u,rho_t1_v = GLOQ.T1ForwardSolve(state_u0,state_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_t1,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\tpopulation_t1 = GLOQ.get_population(rho_t1_u)\n\t# Plot of Ramsey\n\tfig_ramsey = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_ramsey_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\t\t\t          line = (:dash,0.0), marker = ([:hex :hex], 5, 0.5),legend=:outerright,\n\t\t\t\t\t  title=\"Ramsey\");\n\tplot!(fig_ramsey,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_ramsey,label=[\"Opt-0\" \"Opt-1\"],legend=:outerright);\n\t# Plot of Echo\n\tfig_echo = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_echo_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\t\t  \t\t     line = (:dash,0.0), marker = ([:hex :hex], 5, 0.5),legend=:outerright,\n\t\t\t\t\t title=\"Echo\");\n\tplot!(fig_echo,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_echo,label=[\"Opt-0\" \"Opt-1\"],legend=:outerright);\t\t\n\t# Plot of T1\n\tfig_t1=plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_t1_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\t\t\t    line = (:dash,0.0), marker = ([:hex :hex], 5, 0.5),legend=:outerright,\n\t\t\t\ttitle=\"T1\");\n\tplot!(fig_t1,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_t1,label=[\"Opt-0\" \"Opt-1\"],legend=:outerright);\n\n\tdisplay( plot(fig_ramsey,fig_echo,fig_t1,layout=grid(3,1),size=[1000,1500],\n\t\t\t\t  legendfontsize=15,xtickfontsize=15,ytickfontsize=15,titlefontsize=18) )\n\treturn false\nend\n","category":"page"},{"location":"example2/#Step-2c:-define-the-initial-guess-and-bounds-for-the-optimization","page":"Example 2","title":"Step 2c: define the initial guess and bounds for the optimization","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"p_true = [freqs;gamma1;gamma2] # values to generate synthetic data\n# initial guess for the optimization\np_initial = [freqs.-2e-4;0.75.*gamma1;1.25.*gamma2]\n# bounds for the optimization\nlower_bound = (0.5).*p_true\nupper_bound = (1.5).*p_true\n","category":"page"},{"location":"example2/#Step-3:-solve-the-optimization-problem","page":"Example 2","title":"Step 3: solve the optimization problem","text":"","category":"section"},{"location":"example2/#Step-3a:-define-the-optimization-object-(objective-function-and-its-gradient)","page":"Example 2","title":"Step 3a: define the optimization object (objective function and its gradient)","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# construct optimization object, use Zygote auto-differentiation to compute the gradient\nloss_gradient = GalacticOptim.OptimizationFunction(loss, GalacticOptim.AutoZygote())\nopt_prob = GalacticOptim.OptimizationProblem(loss_gradient, p_initial,\n\t\t   lb = lower_bound, ub = upper_bound)\n\n","category":"page"},{"location":"example2/#Step-3b:-solve-the-optimization-problem-with-the-fminbox-of-Optim.jl-through-GalacticOptim.jl-interface","page":"Example 2","title":"Step 3b: solve the optimization problem with the fminbox of Optim.jl through GalacticOptim.jl interface","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"println(\"Optim Fminbox(LBFGS) Optimization starts\")\n@time sol = GalacticOptim.solve(opt_prob ,Fminbox(LBFGS()),\n\t\t\t\tcb = plot_callback,\n\t\t\t\touter_iterations = 20,\n\t\t\t\titerations = 10,\n\t\t\t\tshow_trace=true,\n\t\t\t\tf_tol = 1e-5,\n\t\t\t\touter_f_tol = 1e-5)\nprintln(\"Optim Fminbox(LBFGS) Optimization done\")\n","category":"page"},{"location":"example2/#Step-3c:-present-the-result","page":"Example 2","title":"Step 3c: present the result","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"println(\"\\nOptimized results: \",sol.u,\n        \"\\nLoss: \",sol.minimum,\n\t\t\"\\nError: \",sol.u-p_true)\n","category":"page"},{"location":"example2/#Result:","page":"Example 2","title":"Result:","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Optimized results: [4.1, 2.222222222222221e-5, 4.166666666666682e-5]\nLoss: 1.0455900211204752e-26\nError: [0.0, -1.3552527156068805e-20, 1.5585406229479126e-19]","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"(Image: Example 2: Optimized results v.s. Synthetic data)","category":"page"},{"location":"example2/#Comparison-of-the-synthetic-data-and-forward-solves-with-optimized-parameters.-Population-of-different-states-are-presented.","page":"Example 2","title":"Comparison of the synthetic data and forward solves with optimized parameters. Population of different states are presented.","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Syn-0: synthetic data for the energy level 0; \nSyn-1: synthetic data for the energy level 1; \nOpt-0: optimized result for the energy level 0; \nOpt-1: optimized result for the energy level 1.","category":"page"},{"location":"example2/#The-same-procedure-can-be-applied-to-characterize-the-single-qubit-with-noisy-synthetic-data-of-a-Ramsey-experiment.","page":"Example 2","title":"The same procedure can be applied to characterize the single qubit with noisy synthetic data of a Ramsey experiment.","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Check examples/SingleQubitMultipleExperimentWithNoise.jl for more details. And the corresponding results are as follows.","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Optimized results: [4.10000008455243, 2.263961319781968e-5, 4.846757202378724e-5]\nLoss: 28.043881998133504\nError: [8.455242994642731e-8, 4.1739097559745765e-7, 6.8009053571205745e-6]","category":"page"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"(Image: Example 2: Optimized results v.s. Synthetic data)","category":"page"},{"location":"example2/#Comparison-of-the-noisy-data-and-the-forward-solve-results-of-optimized-parameter-values.-Population-of-different-states-are-presented.","page":"Example 2","title":"Comparison of the noisy data and the forward solve results of optimized parameter values. Population of different states are presented.","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"Noisy-0: noisy data for the energy level 0; \nNoisy-1: noisy data for the energy level 1; \nOpt-0: optimized result for the energy level 0; \nOpt-1: optimized result for the energy level 1.","category":"page"},{"location":"experiment/#Experiments","page":"Experiments","title":"Experiments","text":"","category":"section"},{"location":"experiment/#.-\\pi-pulse-and-\\frac{\\pi}{2}-pulse","page":"Experiments","title":"1. pi-pulse and fracpi2-pulse","text":"","category":"section"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"Pi-pulse: pi_kk+1 is a control pulse that excites the control system from state k to state k+1.\nHalf-pi-pulse: fracpi_kk+12 pulse make the system transit halfway from state k to state k+1.","category":"page"},{"location":"experiment/#.-Rabi-pulse","page":"Experiments","title":"2. Rabi pulse","text":"","category":"section"},{"location":"experiment/#.-Ramsey-Experiment","page":"Experiments","title":"3. Ramsey Experiment","text":"","category":"section"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"The Ramsey experiment is designed to measure the dephasing time T_2 and the detuning frequency from state k to state k+1.  Its workflow is summarized below.","category":"page"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"Prepare the system to be in the excited state k.\nApply the pi_kk+12-pulse  but with a detuned frequency.\nLet the system propagate freely for some dark time t_textrmdark.\nApply the pi_kk+12-pulse again.\nMeasure the population.","category":"page"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"(Image: Ramsey 2-3 experiment)","category":"page"},{"location":"experiment/#A-picture-to-illustrate-the-procedure-of-the-Ramsey-2-3-experiment.","page":"Experiments","title":"A picture to illustrate the procedure of the Ramsey 2-3 experiment.","text":"","category":"section"},{"location":"experiment/#.-T_2-echo-Experiment","page":"Experiments","title":"4. T_2-echo Experiment","text":"","category":"section"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"\"The Echo experiment is a modified version of the Ramsey experiment where a pi pulse is inserted in the middle of the process to enable refocusing and compensate for different spins. This allows the experiment to gather information about the decoherence that is not refocused by the pi pulse.\"[fn1] The workflow of the Echo experiment is as follows.","category":"page"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"Prepare the system to be in excited state k.\nApply the pi_kk+12-pulse.\nLet the system propagate freely for some dark time t_textrmdark.\nApply the pi_kk+1-pule to start the refocusing.\nLet the system propagate freely for some dark time t_textrmdark.\nApply the pi_kk+12-pulse again.\nMeasure the population. ","category":"page"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"(Image: Echo 2-3 experiment)","category":"page"},{"location":"experiment/#A-picture-to-illustrate-the-procedure-of-the-Echo-2-3-experiment.","page":"Experiments","title":"A picture to illustrate the procedure of the Echo 2-3 experiment.","text":"","category":"section"},{"location":"experiment/#.-T_1-decay-Experiment","page":"Experiments","title":"5. T_1-decay Experiment","text":"","category":"section"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"The T_1-decay experiment (also called T_1-relaxation experiment) is an experiment designed to measure the T_1 relaxation time.","category":"page"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"Prepare the system to be in excited state k.\nLet the system evolve freely and relax back to the ground state. Measure populations at different times.","category":"page"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"(Image: T1-decay experiment)","category":"page"},{"location":"experiment/#A-picture-to-illustrate-the-procedure-of-the-T_1-decay-experiment.","page":"Experiments","title":"A picture to illustrate the procedure of the T_1-decay experiment.","text":"","category":"section"},{"location":"experiment/","page":"Experiments","title":"Experiments","text":"[fn1]: Quantum Physics without the Physics, N Anders Petersson, Fortino Garcia, Daniel EA Appelo, Stefanie Günther, Younsoo Choi, Ryan Vogt, arXiv:2012.03865, 2020. ","category":"page"},{"location":"example3/#Example-3:-uncertainty-quantification-for-a-single-qubit-based-on-noisy-data-of-a-Ramsey-experiment.","page":"Example 3","title":"Example 3: uncertainty quantification for a single qubit based on noisy data of a Ramsey experiment.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"In this example, we apply the Metropolis-Hastings algorithm to do uncertainty quantification for a single qubit based on noisy synthetic data of a Ramsey experiment. We provide an interface to the Julia Bayesian inference  package Turing.jl. It can be executed by cd(\"examples\");include(\"SingleQubitBayesian.jl\").","category":"page"},{"location":"example3/#Load-the-needed-packages","page":"Example 3","title":"Load the needed packages","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"using LinearAlgebra\nusing Turing, Distributions, DifferentialEquations\n# Import MCMCChain, Plots, and StatsPlots for visualizations and diagnostics.\nusing MCMCChains, Plots, StatsPlots\nusing CSV,DataFrames\n# Set a seed for reproducibility.\nusing Random\nRandom.seed!(14);\nusing Plots\ninclude(\"../src/GLOQ.jl\")\npyplot()","category":"page"},{"location":"example3/#Step-1:-generate-the-synthetic-data","page":"Example 3","title":"Step 1: generate the synthetic data","text":"","category":"section"},{"location":"example3/#Define-the-system-parameters-and-the-initial-state-vector.","page":"Example 3","title":"Define the system parameters and the initial state vector.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"N_states = 2; # number of states\nfreqs = [4.1] # transition frequency in GHz\nomegas = 2.0*pi.*freqs # change to angular frequency\ngamma1   = [25e-05] # decay\ngamma2   = [25e-05] # dephasing\nomr = 2.0*pi*(4.1 - 1.0e-3) # drive frequency\nTC = 2.5*17.0 # total control time\n\n# Initial state\ninitial_state = 0\nrho_u0 = [0.0;0.0]\nrho_v0 = [0.0;0.0]\nrho_u0[initial_state+1] = 1.0\n\n","category":"page"},{"location":"example3/#Use-forward-solve-to-generate-the-synthetic-data-of-the-Ramsey-experiment.","page":"Example 3","title":"Use forward solve to generate the synthetic data of the Ramsey experiment.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Set up the experiment.","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"# Duration of the Ramsey experiment, largest dark time\nT_Ramsey = 5.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_times = 101\nt_dark_times = collect(range(0.0, T_Ramsey, length=N_dark_times))","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Use GLOQ.RamseyForwardSolve to generate the data, and then obtain the corresponding population.","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"rho_synthetic_ramsey_u,rho_synthetic_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing parameters \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states\npopulation_synthetic = GLOQ.get_population(rho_synthetic_ramsey_u)","category":"page"},{"location":"example3/#Add-multiplicative-and-additive-noise-to-the-generated-synthetic-data.","page":"Example 3","title":"Add multiplicative and additive noise to the generated synthetic data.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"noisy_data = copy(population_synthetic)\nmultiplicative_noise = 1.0.+0.05*randn(N_dark_times) \nnoisy_data .*= multiplicative_noise\nadditive_noise = 0.05*randn(N_dark_times) \nnoisy_data .+= additive_noise","category":"page"},{"location":"example3/#Normalize-the-noisy-data-so-that-it-is-a-population-between-[0,1].","page":"Example 3","title":"Normalize the noisy data so that it is a population between [0,1].","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"for j = 1:N_states\n\tshift = minimum(noisy_data[:,j])\n\tif(shift<0.0)\n\t\tnoisy_data[:,j] .-= shift\n\tend\nend\n\nfor i = 1:N_dark_times\n\tnoisy_data[i,:] ./= sum(noisy_data[i,:])\nend","category":"page"},{"location":"example3/#Plot-the-noisy-data.","page":"Example 3","title":"Plot the noisy data.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"fig = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_synthetic,\n\t\t   label=[\"Syn-0\" \"Syn-1\"])\nscatter!(fig,t_dark_times./GLOQ.GLOQ_MICRO_SEC,noisy_data,\n\t\t label=[\"Noisy-0\" \"Noisy-1\"])\n\np_true = [freqs;gamma1;gamma2]","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: synthetic noisy data)","category":"page"},{"location":"example3/#Synthetic-data-with-and-without-noise.-Population-of-different-states-are-presented.","page":"Example 3","title":"Synthetic data with and without noise. Population of different states are presented.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Syn-0: synthetic data without noise for the energy level 0;\nSyn-1: synthetic data without noise for the energy level 1;\nNoisy-0: noisy data for the energy level 0;\nNoisy-1: noisy data for the energy level 1.","category":"page"},{"location":"example3/#Step-2:-use-@model-macro-to-provide-interface-to-the-Turing.jl-and-apply-the-MCMC-algorithm.","page":"Example 3","title":"Step 2: use @model macro to provide interface to the Turing.jl and apply the MCMC algorithm.","text":"","category":"section"},{"location":"example3/#Step-2a:-use-@model-macro-to-provide-interface-to-the-Turing.jl.-Check-[the-tutorial-of-Turing.jl](https://turing.ml/dev/docs/using-turing/)-for-more-details.","page":"Example 3","title":"Step 2a: use @model macro to provide interface to the Turing.jl. Check the tutorial of Turing.jl for more details.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Below, sigma is a hyper parameter, _freq and _gamma2 are the transition frequency and the dephasing parameter gamma_2. These parameters are sampled based on priori distributions. More specifically, _freq ~ truncated(Normal(4.1,1e-4),4.1-5e-4,4.1+5e-4) means that the random variable _freq is sampled based on a truncated normal distribution whose mean is 41 and standard deviation is 1e-4, and its range is 41-5e-441+5e-4. sigma is sampled based on the inverse gamma distribution and _gamma2 is sampled based on a truncated normal distribution. ","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Based on the sampled parameters, we apply GLOQ.RamseyForwardSolve to perform a forward solve, and the noisy data is assumed to obey  a priori distribution, which is a multivariate-normal distribution whose mean is the forward simulation results and its covariance matrix is sigma I.","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"global sample_number\n@model function RamseyExperiment(data)\n\t # Priori distribution\n\tσ ~ InverseGamma() # random hyper parameter $\\sigma$ obeys an Inverse Gamma distribution.\n    _freq ~ truncated(Normal(4.1,1e-4),4.1-5e-4,4.1+5e-4)\n    _gamma2 ~ truncated(Normal(25e-05,2.5e-5),20e-5,30e-5)\n\t# Perform a Forward solve with sampled parameters\n\t_rho_ramsey_u,_rho_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t\t     2.0*pi*[_freq],omr, # transition frequencies, drive frequency\n\t\t\t\t\t gamma1,[_gamma2], # decay and dephasing parameters ?\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states;\n\t\t\t\t\t method=\"exponential\")\n\t\t\t\t\t #method = Trapezoid()) # control time, dark time, total number of states\n\t_population_ramsey = GLOQ.get_population(_rho_ramsey_u)\n\tfor i = 1:N_dark_times\n        data[i,:] ~ MvNormal(_population_ramsey[i,:], σ)\n    end\n\tglobal sample_number\n\tsample_number += 1\n\tprintln(\"Sample \",sample_number,\" done\")\nend\n\nmodel = RamseyExperiment(noisy_data)","category":"page"},{"location":"example3/#Step-2b:-use-Turing.jl's-sample-function-to-apply-the-Metropolis-Hastings-algorithm.","page":"Example 3","title":"Step 2b: use Turing.jl's sample function to apply the Metropolis-Hastings algorithm.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"In the sample function, the first argument is the target model object, the second argument specifies which sampler is applied, and the  third argument is the length of the chain. Here, we use the standard Metropolis-Hastings sampler with a  diagonal covariance matrix.","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"sample_number = 0\nchain_size = 35000\n@time chain = sample(model, MH(Diagonal([5e-3,5e-3,5e-2])), chain_size)","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Burn-in length is set up as 5000 to improve the quality of the chain. We present the chain after burn-in.","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"BurnIn = 5000\nfig_chain = plot(chain[BurnIn+1:end]);\nxticks!(fig_chain[4],[4.099998;4.10;4.1000015],);\ndisplay(fig_chain)\ndisplay(chain[BurnIn+1:end])","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: chain)","category":"page"},{"location":"example3/#Sampled-Markov-chain-after-burn-in-and-the-corresponding-posteriori-distribution.","page":"Example 3","title":"Sampled Markov chain after burn-in and the corresponding posteriori distribution.","text":"","category":"section"},{"location":"example3/#Step-3:-Present-the-data","page":"Example 3","title":"Step 3: Present the data","text":"","category":"section"},{"location":"example3/#Step-3a:-convert-the-data-to-[DataFrame](https://dataframes.juliadata.org/stable/)-format-and-calculate-the-mean-value-of-the-Markov-chain","page":"Example 3","title":"Step 3a: convert the data to DataFrame format and calculate the mean value of the Markov chain","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"chain_data = DataFrame(chain[BurnIn+1:end])\nfreq_mean = mean(chain_data._freq)\ngamma2_mean = mean(chain_data._gamma2)","category":"page"},{"location":"example3/#Generate-the-Ramsey-curve-corresponding-to-the-mean-value-of-the-chain","page":"Example 3","title":"Generate the Ramsey curve corresponding to the mean value of the chain","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"rho_chain_mean_u,rho_chain_mean_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t\t 2.0*pi*[freq_mean],omr, # transition frequencies, drive frequency\n\t\t\t\t gamma1,[gamma2_mean], # decay and dephasing parameters ?\n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states;\n\t\t\t\t method=\"exponential\")\npopulation_chain_mean = GLOQ.get_population(rho_chain_mean_u)","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Compare the results with noisy data.","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"fig_mean_vs_noisy = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_chain_mean,\n\t\t   \t\t  label=[\"Mean-0\" \"Mean-1\"])\nscatter!(fig_mean_vs_noisy,t_dark_times./GLOQ.GLOQ_MICRO_SEC,noisy_data,\n\t\t label=[\"Noisy data-0\" \"Noisy data-1\"])\ndisplay(fig_mean_vs_noisy)","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: mean value vs noisy data)","category":"page"},{"location":"example3/#The-Ramsey-curve-corresponding-to-the-mean-value-vs-data-with-noise.-Mean-0-and-Mean-1:-the-Ramsey-curve-corresponding-to-the-mean-value-of-the-chain-for-the-energy-level-0-and-1.-Noisy-0-and-Noisy-1:-noisy-data-for-the-energy-level-0-and-1.","page":"Example 3","title":"The Ramsey curve corresponding to the mean value vs data with noise. Mean-0 and Mean-1: the Ramsey curve corresponding to the mean value of the chain for the energy level 0 and 1. Noisy-0 and Noisy-1: noisy data for the energy level 0 and 1.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Compare the results with noise-free data.","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"fig_mean_vs_syn = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_chain_mean,\n\t\t\t\t   label=[\"Mean-0\" \"Mean-1\"])\nscatter!(fig_mean_vs_syn,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_synthetic,\n\t\t label=[\"Syn-0\" \"Syn-1\"])\ndisplay(fig_mean_vs_syn)","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: mean value vs data without noise)","category":"page"},{"location":"example3/#The-Ramsey-curve-corresponding-to-the-mean-value-vs-synthetic-data-without-noise.-Mean-0-and-Mean-1:-the-Ramsey-curve-corresponding-to-the-mean-value-of-the-chain-for-the-energy-level-0-and-1.-Syn-0-and-Syn-1:-synthetic-data-without-noise-for-the-energy-level-0-and-1.","page":"Example 3","title":"The Ramsey curve corresponding to the mean value vs synthetic data without noise. Mean-0 and Mean-1: the Ramsey curve corresponding to the mean value of the chain for the energy level 0 and 1. Syn-0 and Syn-1: synthetic data without noise for the energy level 0 and 1.","text":"","category":"section"},{"location":"example3/#Display-the-difference-between-the-mean-value-of-the-chain-and-the-true-value","page":"Example 3","title":"Display the difference between the mean value of the chain and the true value","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"println( \"Error of freqs: \",abs(freq_mean-freqs[1]),\n\t\t \" Error of γ₂: \",abs(gamma2_mean-gamma2[1]) )","category":"page"},{"location":"example3/#Results:","page":"Example 3","title":"Results:","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Error of freqs: 3.7845511347001093e-7 Error of γ₂: 8.2938489833124e-7","category":"page"},{"location":"example3/#Sample-from-the-Markov-chain-and-perform-forward-solves,-then-we-compare-the-sampled-results-with-the-noisy-data-and-the-forward-solve-with-parameters-corresponding-to-the-mean-value-of-the-chain.","page":"Example 3","title":"Sample from the Markov chain and perform forward solves, then we compare the sampled results with the noisy data and the forward solve with parameters corresponding to the mean value of the chain.","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"global fig_result\nfor i = 1:1000\n\tglobal fig_result\n\tsample_ind = rand(1:chain_size-BurnIn)\n    freq_sample = chain_data._freq[sample_ind]\n    gamma2_sample = chain_data._gamma2[sample_ind]\n    rho_sample_u,rho_sample_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t\t 2.0*pi*[freq_sample],omr, # transition frequencies, drive frequency\n\t\t\t\t gamma1,[gamma2_sample], # decay and dephasing parameters \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states;\n\t\t\t\t method=\"exponential\")\n    population_sample = GLOQ.get_population(rho_sample_u)\n\tif (i==1)\n    \tfig_result=plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_sample,\n              color = \"#BBBBBB\", label=\"\");\n\telse\n    \tplot!(fig_result,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_sample,\n              color = \"#BBBBBB\", label=\"\");\n\tend\nend\nplot!(fig_result,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_chain_mean,\n\t  linewidth=1.0,label=[\"Mean-0\" \"Mean-1\"])\nscatter!(fig_result,t_dark_times./GLOQ.GLOQ_MICRO_SEC,noisy_data,\n\t     label=[\"Noisy data-0\" \"Noisy data-1\"])\ndisplay(fig_result)","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: the Ramsey results corresponding to the posterior distribution and the mean results)","category":"page"},{"location":"example3/#Compare-the-Ramsey-curves-generated-by-the-samples-from-the-chain.-Mean-0-and-Mean-1:-the-Ramsey-curve-corresponding-to-the-mean-value-of-the-chain-for-the-energy-level-0-and-1.-Noisy-0-and-Noisy-1:-noisy-synthetic-data-for-the-energy-level-0-and-1.","page":"Example 3","title":"Compare the Ramsey curves generated by the samples from the chain. Mean-0 and Mean-1: the Ramsey curve corresponding to the mean value of the chain for the energy level 0 and 1. Noisy-0 and Noisy-1: noisy synthetic data for the energy level 0 and 1.","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The GLOQ.jl package aims at solving quantum characterization problems with deterministic optimization or Bayesian inference methods. ","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The general work flow for solving a quantum characterization problem consists of the following general steps:","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Setup the characterization problem.\nPerform optimization/Bayesian inference.","category":"page"},{"location":"workflow/#Deterministic-optimization","page":"Workflow","title":"Deterministic optimization","text":"","category":"section"},{"location":"workflow/#.-Setup","page":"Workflow","title":"1. Setup","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The setup phase includes specifying","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Load the experimental/synthetic data\nSpecify the known parameters\nNumber of the states","category":"page"},{"location":"workflow/#.-Optimization","page":"Workflow","title":"2. Optimization","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Set up initial guess and the bounds for target parameters\nCreate the objective function by fitting the data set with forward solves\nOptional: compute/approximate the Jacobian of the loss function. By default, auto-differentiation (Zygote.jl) or finite-difference approximation will be used.\nFeed the loss function and its Jacobian to the interface of optimization package.","category":"page"},{"location":"workflow/#Bayesian-inference-with-Turing.jl","page":"Workflow","title":"Bayesian inference with Turing.jl","text":"","category":"section"},{"location":"workflow/#.-Setup-2","page":"Workflow","title":"1. Setup","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The setup phase includes specifying","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Load the experimental/synthetic data\nSpecify the known parameters\nNumber of the states","category":"page"},{"location":"workflow/#.-Bayesian-inference-with-[Turing.jl](https://turing.ml/stable/)","page":"Workflow","title":"2. Bayesian inference with Turing.jl","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Use @model interface of Turing.jl to define a model object fitting the data based on some random parameter values sampled from some priori and proposal distributions.\nFeed the model object to the interface of a Markov Chain Monte-Carlo (MCMC) sampler.","category":"page"},{"location":"model/#Lindblad-equation","page":"Lindblad equation","title":"Lindblad equation","text":"","category":"section"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"The governing equation of an open quantum system is the Lindblad equation. We consider the N energy level Lindblad equation:","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"beginequation\ndotrho = -ileft(Hrho - rho Hright) + sum_j=1^2 left( cal L_j rho cal L_j^dagger -\nfrac12left( cal L_j^daggercal L_jrho + rhocal L_j^daggercal L_j right) right)\nendequation","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"Here, rho(t) is the density matrix, H(t) is a Hamiltonian operator, and operators cal L_1 and cal L_2 model the decay and dephasing mechanism.","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"By default, the Hamiltonian is in the form of H(t)=H_rm 0+H_c(t), where","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"H_rm 0 = left\nbeginarraycccc\n0         \n   omega_01     \n      omega_01 + omega_12    \n         ddots   \n                  sum_k=0^N-1omega_N-1N\nendarray\nright","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"is the system Hamiltonian, and H_c(t) is the control Hamiltonian. The decay operator cal L_1 is in the form ","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"cal L_1 = left\nbeginarraycccc\n0  sqrtgamma_11      \n   0  sqrtgamma_12    \n      ddots  ddots   \n            0  sqrtgamma_1N-1 \n                0\nendarrayright","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"and the dephasing operator cal L_2 is in the form ","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"cal L_2 = left\nbeginarraycccc\n0          \n   sqrtgamma_21        \n      sqrtgamma_22     \n          ddots   \n                   sqrtgamma_2N-1\nendarray\nright","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"The thermal relaxation time for energy level k is T_1k=1gamma_1k, and the  dephasing time for energy level k is T_2k=1gamma_2k.","category":"page"},{"location":"model/#Lindblad-equation-with-charge-noise","page":"Lindblad equation","title":"Lindblad equation with charge noise","text":"","category":"section"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"We also consider the Lindblad model with charge noise. In this case, the system Hamiltonian is","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"H_rm 0 = left\nbeginarraycccc\n0         \n   widetildeomega_01     \n      widetildeomega_01 + widetildeomega_12    \n         ddots   \n                  sum_k=0^N-1widetildeomega_N-1N\nendarray\nright","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"and  widetildeomega_kk+1=omega_kk+1-pi d_kk+1cosleft(pifracC+peeright) Here, pin01 is the parity, d_kk+1 is the charge dispersion, C is the charge over the Josephson junction, e is the charge of an electron, and fracCein01.","category":"page"},{"location":"model/","page":"Lindblad equation","title":"Lindblad equation","text":"For now, we neglect the charge noise due to the charge event (the effect of Ce) and only consider the charge noise due to the parity event (the effect of p).  In the numerical simulation, we take the average of the forward solve of the deterministic Lindblad equation with p=0 and p=1. ","category":"page"},{"location":"example1/#Example-1:-characterization-of-a-single-qubit-Ramsey-experiment","page":"Example 1","title":"Example 1: characterization of a single qubit Ramsey experiment","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"In this example, we solve a single qubit characterization problem based on the synthetic data of a Ramsey experiment. We the transition frequency omega_01 and seek the dephasing time T_2=1gamma_2. We first consider a synthetic data set without noise. The code can be ran by cd(\"examples\");include(\"SingleQubitRamsey.jl\"). ","category":"page"},{"location":"example1/#Step-1:-generate-the-synthetic-data","page":"Example 1","title":"Step 1: generate the synthetic data","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"We first set up the system parameters. The number of states is N_states=2 for the single qubit. freqs, gamma1, gamma2 are vectors saving the transition frequencies, the reciprocal of relaxation time and the reciprocal of dephasing time. The unit for these parameters are GHz.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# System parameters for a simple two level open quantum system\nN_states = 2; # number of states\nfreqs = [4.1] # transition frequency in GHz\nomegas = 2.0*pi.*freqs # change to angular frequency\ngamma1   = [1.0/(55.0*GLOQ.GLOQ_MICRO_SEC)] # Reciprocal of relaxation time - T1 (in units of ns)\ngamma2   = [1.0/(15.0*GLOQ.GLOQ_MICRO_SEC)] # Reciprocal of dephasing time - T2 (in units of ns)\nomr = 2.0*pi*(4.1 - 5.0e-4) # drive frequency\nTC = 2.5*17.0 # total control time in ns needed for a Rabi pulse, check the page of experiments for more details ","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Initial state vector is mathcals=(10)^T+i(00)^T. In other words, the initial density matrix is  rho=mathcalsmathcals^dagger=left(beginmatrix 1  0\n0  0 endmatrixright)","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# Initial state\ninitial_state = 0\nstate_u0 = [0.0;0.0]\nstate_v0 = [0.0;0.0]\nstate_u0[initial_state+1] = 1.0","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"The duration of the Ramsey experiment is 40.0 mu s, and 401 dark times are uniformly sampled.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# Duration of the Ramsey experiment, largest dark time given in Microseconds\nT_Ramsey = 40.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_times = 401\nt_dark_times = collect(range(0.0, T_Ramsey, length=N_dark_times))","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Use GLOQ.RamseyForwardSolve to perform a forward solve to generate the  synthetic data of the Ramsey experiment. ","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# Forward solve to generate synthetic data\nrho_synthetic_ramsey_u,rho_synthetic_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t state_u0,state_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t\t omegas,omr, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing parameters \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Use GLOQ.get_population to compute the population based on the real part of the density matrix which is flattend and saved as a vector rho_synthetic_ramsey_u.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"population_synthetic = GLOQ.get_population(rho_synthetic_ramsey_u)","category":"page"},{"location":"example1/#Step-2:-define-the-objective-function,-initial-guess-and-optimization-bounds","page":"Example 1","title":"Step 2: define the objective function, initial guess and optimization bounds","text":"","category":"section"},{"location":"example1/#Step-2a:-define-the-cost-objective-function.-Here,-we-use-the-normalized-l2-mismatch.","page":"Example 1","title":"Step 2a: define the cost objective function. Here, we use the normalized l2-mismatch.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Suppose the number of dark times in the Ramsey experiment to be N_textrmDark. The objective function (loss in the code) is defined as ","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"bigbig textrmForward Solve Results-textrmSynthetic Databigbig_2^2N_textrmDark","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"with cdot_2 being the standard l_2 norm.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"In the objective function loss(p,dummy_parameter), the first argument p saves the target parameter (omega_01gamma_2) and the second argument dummy_parameter is needed by the optimization interface GalacticOptim which can be simply set up  as []. ","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# Define the loss function for the GalacticOptim\n# p: phyiscal parameters:\n#\t p[1] = transition frequency in GHz\n#\t p[2] = gamma2\n# dummy_parameter: needed by GalacticOptim, one can just put [] here\nfunction loss(p,dummy_parameter)\n\t_rho_ramsey_u,_rho_ramsey_v = GLOQ.RamseyForwardSolve(state_u0,state_v0,\n\t\t\t\t\t (2*pi).*[p[1]],omr,\n\t\t\t\t\t gamma1,[p[2]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\t_population_ramsey = GLOQ.get_population(_rho_ramsey_u)\n\n\t_loss = sum(abs2,_population_ramsey-population_synthetic)/N_dark_times\n\treturn _loss\nend","category":"page"},{"location":"example1/#Step-2b:-define-a-callback-function-to-plot-while-optimizing","page":"Example 1","title":"Step 2b: define a callback function to plot while optimizing","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"plot_callback = function(p,other_args)\n\trho_ramsey_u,rho_ramsey_v = GLOQ.RamseyForwardSolve(state_u0,state_v0,\n\t\t\t\t\t (2*pi).*[p[1]],omr,\n\t\t\t\t\t gamma1,[p[2]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\tpopulation_ramsey = GLOQ.get_population(rho_ramsey_u)\n\tfig=plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\t\t\t line = (:dash,0.0), marker = ([:hex :hex], 5, 0.5)  )\n\tplot!(fig,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_ramsey,label=[\"Opt-0\" \"Opt-1\"]\n\t\t )\t\t\t\n\tdisplay(fig)\n    return false\nend","category":"page"},{"location":"example1/#Step-2c:-Initial-guess-and-bounds-for-the-optimization","page":"Example 1","title":"Step 2c: Initial guess and bounds for the optimization","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"p_true = [freqs;gamma2] # values to generate synthetic data\n# initial guess for the optimization\np_initial = [freqs .- 0.5e-4;0.9.*gamma2]\n\n# bounds for the optimization\nlower_bound = (0.5).*p_true\nupper_bound = (1.5).*p_true","category":"page"},{"location":"example1/#Step-3:-solve-the-optimization-problem","page":"Example 1","title":"Step 3: solve the optimization problem","text":"","category":"section"},{"location":"example1/#Step-3a:-define-the-optimization-object.","page":"Example 1","title":"Step 3a: define the optimization object.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"The first argument of GalacticOptim.OptimizationFunction is the objective function, and the second argument specifies how the gradient will be computed. Here, the auto-differentiation package Zygote.jl is used. Other options and settings can be found in GalaticOptim.OptimizationFunction.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# construct optimization object, use Zygote auto-differentiation to compute the gradient\nloss_gradient = GalacticOptim.OptimizationFunction(loss, GalacticOptim.AutoZygote())\nopt_prob = GalacticOptim.OptimizationProblem(loss_gradient, p_initial,\n\t\t\t\t\tlb = lower_bound, ub = upper_bound)","category":"page"},{"location":"example1/#Step-3b:-solve-the-optimization-problem-with-[GalacticOptim.solve](https://galacticoptim.sciml.ai/stable/API/solve/).","page":"Example 1","title":"Step 3b: solve the optimization problem with GalacticOptim.solve.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Here, we use the Optim.jl and NLopt.jl interface of GalacticOptim.jl. Other available optimizer packages and more optimizer specific options are documented in GalacticOptim.jl. ","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Use the fminbox of Optim.jl as the optimizer.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"println(\"Optim Fminbox(LBFGS) Optimization starts\")\n@time sol = GalacticOptim.solve(opt_prob ,Fminbox(LBFGS()),\n\t\t\tcb = plot_callback,\n\t\t\touter_iterations = 20,\n\t\t\titerations = 10,\n\t\t\tshow_trace=true,\n\t\t\tf_tol = 1e-10,\n\t\t\touter_f_tol = 1e-10)\nprintln(\"Optim Fminbox(LBFGS) Optimization done\")","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Use the LBFGS of NLopt.jl as the optimizer.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"println(\"NLopt LBFGS Optimization starts\")\n@time sol_nlopt_LBFGS = GalacticOptim.solve(opt_prob, Opt(:LD_LBFGS,length(p_initial)),\n\t\t\tmaxiters=200,\n\t\t\tcb = plot_callback,\n\t\t\tftol_rel=1e-7)\nprintln(\"NLopt LBFGS Optimization done\")","category":"page"},{"location":"example1/#Step-3c:-present-the-result","page":"Example 1","title":"Step 3c: present the result","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# present the solutions\nprintln(\"\\nOptimized results: \",sol.u,\n        \"\\nLoss: \",sol.minimum,\n\t\t\"\\nError: \",sol.u-p_true)","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Optimized results: [4.099, 6.666666666665127e-5]\nLoss: 8.029671826634274e-28\nError: [-0.0009999999999994458, -1.5395670849294163e-17]","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"(Image: Example 1: Optimized results v.s. Synthetic data)","category":"page"},{"location":"example1/#Comparison-of-the-synthetic-data-and-the-forward-solve-results-of-optimized-parameter-values.-Population-of-different-states-are-presented.","page":"Example 1","title":"Comparison of the synthetic data and the forward solve results of optimized parameter values. Population of different states are presented.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Syn-0: synthetic data for the energy level 0; \nSyn-1: synthetic data for the energy level 1; \nOpt-0: optimized result for the energy level 0; \nOpt-1: optimized result for the energy level 1.","category":"page"},{"location":"example1/#The-same-procedure-can-be-applied-to-characterize-the-single-qubit-with-noisy-synthetic-data-of-a-Ramsey-experiment.","page":"Example 1","title":"The same procedure can be applied to characterize the single qubit with noisy synthetic data of a Ramsey experiment.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Check examples/SingleQubitRamseyWithNoise.jl for more details. And the corresponding results are as follows.","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Optimized results: [4.0999999983533915, 7.229921553726332e-5]\nLoss: 0.0015030181815031656\nError: [-1.6466081831367774e-9, 5.632548870596654e-6]","category":"page"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"(Image: Example 1: Optimized results v.s. Synthetic data)","category":"page"},{"location":"example1/#Comparison-of-the-noisy-data-and-the-forward-solve-results-of-optimized-parameter-values.-Population-of-different-states-are-presented.","page":"Example 1","title":"Comparison of the noisy data and the forward solve results of optimized parameter values. Population of different states are presented.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"Noisy-0: noisy data for the energy level 0; \nNoisy-1: noisy data for the energy level 1; \nOpt-0: optimized result for the energy level 0; \nOpt-1: optimized result for the energy level 1.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"The following methods (functions) are exported and available by using GLOQ.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [GLOQ]\nOrder = [:function]","category":"page"},{"location":"methods/#GLOQ.EchoForwardSolve","page":"Methods","title":"GLOQ.EchoForwardSolve","text":"EchoForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,tdark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1: the decay parameter  of the Lindblad operators, equal to 1T_1 with T_1 being the relaxation time\ngamma2: the dephasing parameter  of the Lindblad operators, equal to 1T_2 with T_2 being the dephasing time\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdark_times: the dark time in the Ramsey experiment\nN_states: number of states. If it is not specified, thedefault value will be 0, and the code will automatically detect how many states are considered.  \ninitial_type: type of the initial condition\ninitial values are state vectors (default choice)\ninitial values are density matrices saving in flattened vectors\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator (default choice)\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers available in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nOutput:\n\nrho_urho_v: real and imaginary part of the density matrix rho=rho_u-irho_v at sampled dark times, and they are saved as flattened vectors\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.EchoParityForwardSolve","page":"Methods","title":"GLOQ.EchoParityForwardSolve","text":"EchoParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,tdark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1: the decay parameter  of the Lindblad operators, equal to 1T_1 with T_1 being the relaxation time\ngamma2: the dephasing parameter  of the Lindblad operators, equal to 1T_2 with T_2 being the dephasing time\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdark_times: the dark time in the Ramsey experiment\nN_states: number of states. If it is not specified, the default value will be 0, and the code will automatically detect how many states are considered.  \ninitial_type: type of the initial condition\ninitial values are state vectors (default choice)\ninitial values are density matrices saving in flattened vectors\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator (default choice)\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers available in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrho_urho_v: real and imaginary part of the density matrix rho=rho_u-irho_v at sampled dark times, and they are saved as flattened vectors\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.LindbladODEProblem-Tuple{Any,Any,Array{Float64,2},Array{Float64,N} where N,Array{Float64,2},Float64}","page":"Methods","title":"GLOQ.LindbladODEProblem","text":"LindbladODEProblem(rho_u0,rho_v0,LK::Array{Float64,2},LS::Array{Float64},LD::Array{Float64,2},time_final::Float64;initial_type = \"density\")\n\nFunction provides interfaces to DifferentialEquations package to solve the real-valued Lindblad system: (rho_u - i rho_v)_t = -i (L_K+iL_S)(rho_u-i rho_v) + L_D(rho_u-i rho_v)\n\nArgument:\n\nrho_u0 rho_v0: initial condition rho_0 = rho_u0 - i rho_v0\nLK: real part of the Hamiltonian operator\nLS: imaginary part of the Hamiltonain operator\nLD: Lindblad operator\ntime: final time or time beining evaluated\ninitial_type: specify initial value is a density matrix/a state vector\n\nOutput:\n\nA problem object which we will feed to DifferentialEquations.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.LindbladODEProblemComplex-Tuple{Any,Array{Complex{Float64},2},Float64}","page":"Methods","title":"GLOQ.LindbladODEProblemComplex","text":"LindbladODEProblemComplex(rho0,L::Array{ComplexF64,2},time_final::Float64;initial_type = \"density\")\n\nFunction provide interfaces to DifferentialEquations package to solve: rho_t = L rho\n\nArgument:\n\nL: Lindblad operator\ntime: final time or time beining evaluated\nrho0: initial condition\ninitial_type: specify initial value is a density matrix/a state vector\n\nOutput:\n\nA complex-valued problem object which we will feed to DifferentialEquations.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RamseyForwardSolve","page":"Methods","title":"GLOQ.RamseyForwardSolve","text":"RamseyForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t\t  omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t\t  gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t\t  InitialState::Int64,\n\t\t\t\t\t  TC::Float64,tdark_times::Array{Float64},\n\t\t\t\t   \t  N_states::Int64=0;\n\t\t\t\t      initial_type=\"states\",\n\t\t\t\t   \t  method=\"exponential\",\n\t\t\t\t      DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1: the decay parameter  of the Lindblad operators, equal to 1T_1 with T_1 being the relaxation time\ngamma2: the dephasing parameter  of the Lindblad operators, equal to 1T_2 with T_2 being the dephasing time\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdark_times: the dark time in the Ramsey experiment\nN_states: number of states. If it is not specified, the default value will be 0, and the code will automatically detect how many states are considered.  \ninitial_type: type of the initial condition\ninitial values are state vectors (default choice)\ninitial values are density matrices saving in flattened vectors\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator (default choice)\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers available in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nOutput:\n\nrho_urho_v: real and imaginary part of the density matrix rho=rho_u-irho_v at sampled dark times, and they are saved as flattened vectors\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.RamseyParityForwardSolve","page":"Methods","title":"GLOQ.RamseyParityForwardSolve","text":"RamseyParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive:Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitalState::Int64,\n\t\t\t\t   TC::Float64,tdark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1: the decay parameter  of the Lindblad operators, equal to 1T_1 with T_1 being the relaxation time\ngamma2: the dephasing parameter  of the Lindblad operators, equal to 1T_2 with T_2 being the dephasing time\nInitial State: initial state of the density matrix\nTC: control time of the control signal\ndark_times: the dark time in the Ramsey experiment\nN_states: number of states. If it is not specified, the default value will be 0, and the code will automatically detect how many states are considered.  \ninitial_type: type of the initial condition\ninitial values are state vectors (default choice)\ninitial values are density matrices saving in flattened vectors\nmethod: method to solve the Landlady system\n\n\"exponential\": exponential time integrator (default choice)\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers available in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrho_urho_v: real and imaginary part of the density matrix rho=rho_u-irho_v at sampled dark times, and they are saved as flattened vectors\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.RotationFrameDiagonal-Tuple{Array{Float64,N} where N,Float64}","page":"Methods","title":"GLOQ.RotationFrameDiagonal","text":"RotationFrameDiagonal(omega::Array{Float64},omega_drive::Float64)\n\nArgument:\n\nomega: transition frequencies\nomega_drive: driving frequency\nN: number of states\n\nOutput:\n\nDiagonal matrix diag{0,omega[1]-omr,omega[2]-omr,...,omega[N-1]-omr}\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameLindblad-Tuple{Array{Float64,N} where N,Array{Float64,N} where N}","page":"Methods","title":"GLOQ.RotationFrameLindblad","text":"RotationFrameDiagonal(gamma1::Array{Float64},gamma2::Array{Float64})\n\nArgument:\n\ngamma1: determine the decay operator in the Lindblad system\ngamma2: determine the dephasing operator in the Lindblad system\n\nOutput:\n\nLdecay: Ldecay[i][i+1] = sqrt(gamma1[i]), and zeros everywhere else\nLdephase: Diagonal{0,sqrt(gamma2[1]),...)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameRamseyControl-Tuple{Float64,Float64,Int64}","page":"Methods","title":"GLOQ.RotationFrameRamseyControl","text":"RotationFrameRamseyControl(abs_control::Float64,phase_control::Float64,N::Int64)\n\nArgument:\n\nabs_control: strength of the control Omega\nphase_control: phase of the control signal theta\nN: number of states\n\nOutput:\n\nHCK,HCS: the real and imaginary part of the control operator, determined by p(a+a^dagger)+iq(a-a^dagger) where a is the lowering operator, p=Omegacos(theta) and q=Omegasin(theta)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameRamseyControl-Tuple{Int64}","page":"Methods","title":"GLOQ.RotationFrameRamseyControl","text":"RotationFrameRamseyControl(N::Int64)\n\nArgument:\n\nabs_control: strength of the control Omega\nphase_control: phase of the control signal theta\nN: number of states\n\nOutput:\n\nHCK,HCS: the real and imaginary part of the control operator, determined by (a+a^dagger)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.T1ForwardSolve","page":"Methods","title":"GLOQ.T1ForwardSolve","text":"T1ForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,tdark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1: the decay parameter  of the Lindblad operators, equal to 1T_1 with T_1 being the relaxation time\ngamma2: the dephasing parameter  of the Lindblad operators, equal to 1T_2 with T_2 being the dephasing time\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdark_times: the dark time in the Ramsey experiment\nN_states: number of states. If it is not specified, the default value will be 0, and the code will automatically detect how many states are considered.  \ninitial_type: type of the initial condition\ninitial values are state vectors (default choice)\ninitial values are density matrices saving in flattened vectors\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator (default choice)\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers available in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nOutput:\n\nrho_urho_v: real and imaginary part of the density matrix rho=rho_u-irho_v at sampled dark times, and they are saved as flattened vectors\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.T1ParityForwardSolve","page":"Methods","title":"GLOQ.T1ParityForwardSolve","text":"T1ParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,tdark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1: the decay parameter  of the Lindblad operators, equal to 1T_1 with T_1 being the relaxation time\ngamma2: the dephasing parameter  of the Lindblad operators, equal to 1T_2 with T_2 being the dephasing time\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdark_times: the dark time in the Ramsey experiment\nN_states: number of states. If it is not specified, the default value will be 0, and the code will automatically detect how many states are considered.  \ninitial_type: type of the initial condition\ninitial values are state vectors (default choice)\ninitial values are density matrices saving in flattened vectors\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator (default choice)\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers available in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrho_urho_v: real and imaginary part of the density matrix rho=rho_u-irho_v at sampled dark times, and they are saved as flattened vectors\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.about-Tuple{}","page":"Methods","title":"GLOQ.about","text":"About GLOQ.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.convert_state_to_density-Tuple{Array{Float64,1},Array{Float64,1}}","page":"Methods","title":"GLOQ.convert_state_to_density","text":"convert_state_to_density(u::Array{Float64,1},v::Array{Float64,1})\n\nArgument:\n\nstate vector: u-iv\n\nOutput:\n\nvectorized density matrix: rhou-i rhov\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.exponential_solver","page":"Methods","title":"GLOQ.exponential_solver","text":"exponential_solver(rho_u0,rho_v0,LK,LS,LD,t_span,N=0;initial_type = \"density\")\n\nPurpose:\n\nuse an exponential integrator to integrate\nrho_t=-i(L_K+iL_S) rho+L_D  ho\n\nArgument:\n\nrho_u0rho_v0: rho0 =\\rho{u0} - i \\rho{v0}``\nLK: real part of the Hamiltonian operator\nLS: imaginary part of the Hamiltonain operator\nLD: Lindblad operator\nt_span: where the solution will be stored\ninitial_type: \"density\" vectorized density matrix, \"states\" states vector\n\nOutput:\n\nrhou,rhov: solutions at tspan given by ``\\rho(ti) =  hou(:,i)-i  hov(:,i)``\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.exponential_solver_complex-Tuple{Any,Any,Array{Float64,N} where N}","page":"Methods","title":"GLOQ.exponential_solver_complex","text":"exponential_solver_complex(rho_vec0,L,t_span::Array{Float64};initial_type = \"density\"):\n\nArgument:\n\nL: the whole propagation operator\nt_span: where the function will be evaluated stored in\nrho0_vec: initial density/state\ninitial_type: decide we aer given an initial density matrix or a state vector\n\nOutput:\n\nsolutions at t_span\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.exponential_solver_complex-Tuple{Any,Any,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}","page":"Methods","title":"GLOQ.exponential_solver_complex","text":"exponential_solver_complex(rho_vec0,L,t_span::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}};\n                   initial_type = \"density\")\n\nArgument:\n\nL: the whole propagation operator\nt_span: where the function will be evaluated stored in\nrho0_vec: initial density/state\ninitial_type: decide we aer given an initial density matrix or a state vector\n\nOutput:\n\nComplex-valued solutions at t_span\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Complex{Float64},1}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(rho_vec::Array{ComplexF64,1})\n\nArgument:\n\nrho_vec, density matrix in the vector form\n\nOutput:\n\nthe population in an array\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Complex{Float64},2}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(RhoVecHistory::Array{ComplexF64,2})\n\nArgument:\n\nRhoVecHistory, time history for the vectorized density matrix,\n\ni-th column corresponding to the i-th time point\n\nOutput:\n\nThe population history P which is a 2D array, P[i,j] is corresponding\n\nto time point i and state j\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Float64,2}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(RhoRealHistory::Array{Float64,2})\n\nArgument:\n\nRhoRealHistory: time history for the real part of the density matrix (saved as a flattened vector), j-th column corresponding to the j-th time point\n\nrhohistory = rhouhistory - i rhov_history.\n\nSince the density matrix should be Hermitian, it is good enough to just have the real part.\n\nOutput:\n\nThe population history P which is a 2D array, P[i,j] is corresponding\n\nto time point i and state j\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.hello_world-Tuple{}","page":"Methods","title":"GLOQ.hello_world","text":"hello_world():\n\nA hello world function\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.make_hamiltonian_operator","page":"Methods","title":"GLOQ.make_hamiltonian_operator","text":"make_Hamiltonian_operator(HK::Array{Float64,2},HS::Array{Float64,2},N::Int64=0)\n\nArgument:\n\nThe real part and the imaginary part of the Hamiltonian: H = H_K-i H_S\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLK: real matrix corresponding to the real part of the Hamiltonian operator\nLS: real matrix corresponding to the imaginary part of the Hamiltonian operator\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.make_hamiltonian_operator-2","page":"Methods","title":"GLOQ.make_hamiltonian_operator","text":"make_Hamiltonian_operator(HK::Array{Float64,2},N::Int64=0)\n\nArgument:\n\nThe real part and the imaginary part of the Hamiltonian: H = H_K\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLK: real matrix corresponding to the real part of the Hamiltonian operator\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.make_lindblad_operator","page":"Methods","title":"GLOQ.make_lindblad_operator","text":"make_lindblad_operator(HK::Array{Float64,2},HS::Array{Float64,2},L_list,N::Int64=0)\n\nArgument:\n\nThe real part and the imaginary part of the Hamiltonian: H = H_K-i H_S\nA list of Lindblad terms L_k's\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLK: real matrix corresponding to the real part of the Hamiltonian operator\nLS: real matrix corresponding to the imaginary part of the Hamiltonian operator\nLD: real matrix corresponding to the Lindblad operator\nFinal system: rho_t = -i(L_K+i L_S)rho+L_D rho\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.make_lindblad_operator_complex","page":"Methods","title":"GLOQ.make_lindblad_operator_complex","text":"make_lindblad_operator_complex(H::Array{ComplexF64,2},L_list,N::Int64=0)\n\nArgument:\n\nthe Hamiltonain H and a list of Lindblad terms L_k's\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLH: complex matrix corresponding to the Hamiltonian operator\nLD: complex matrix corresponding to the Lindblad operator\n\n\n\n\n\n","category":"function"},{"location":"#GLOQ.jl","page":"Home","title":"GLOQ.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GLOQ.jl (Göran Lindblad Open Quantum systems) is a Julia package solving characterization problems for open quantum systems based on Lindblad equations with deterministic optimization method and Bayesian inference.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GLOQ.jl provides Julia native implementations of forward Lindblad solves with interfaces to the differential equation solver DifferentialEquations.jl, a unified Julia interface to various optimization packages GalacticOptim.jl, and the Julia Bayesian inference package Turing.jl (partially supported for now). ","category":"page"},{"location":"function-index/","page":"Index","title":"Index","text":"Modules = [GLOQ]","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The following types are exported and available by using GLOQ.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [GLOQ]\nOrder = [:type]","category":"page"}]
}
