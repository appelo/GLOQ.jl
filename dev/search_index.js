var documenterSearchIndex = {"docs":
[{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The work flow for solving a quantum characterization problem consists of the following general steps:","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Setup\nOptimize","category":"page"},{"location":"workflow/#.-Setup","page":"Workflow","title":"1. Setup","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The setup phase includes specifying","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Load the experimental/synthetic data\nSpecify the known parameters\nNumber of the states\nSet up initial guess and the bounds for target parameters\nCreate the loss (objective) function by fitting the data set with forward solves\nOptional: compute/approximate the Jacobian of the loss function. By default, auto-differentiation (Zygote.jl) or finite-difference approxiamtion will be used.","category":"page"},{"location":"workflow/#.-Optimization","page":"Workflow","title":"2. Optimization","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Feed the loss function and its Jacobian to the interface of optimization package.","category":"page"},{"location":"example1/#Example-1:-characterization-of-the-Ramsey-experiment-with-single-qudit","page":"Example 1","title":"Example 1: characterization of the Ramsey experiment with single qudit","text":"","category":"section"},{"location":"example1/#Step-1:-generate-the-synthetic-data","page":"Example 1","title":"Step 1: generate the synthetic data","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# System parameters for a simple two level open quantum system\nN_states = 2; # number of states\nfreqs = [4.1] # transition frequency in GHz\nomegas = 2.0*pi.*freqs # change to angular frequency\ngamma1   = [25e-05] # decay???\ngamma2   = [25e-05] # dephasing???\nomr = 2.0*pi*(4.1 - 1.0e-3) # drive frequency\nTC = 2.5*17.0 # total control time\n\n# Initial state\ninitial_state = 0\nrho_u0 = [0.0;0.0]\nrho_v0 = [0.0;0.0]\nrho_u0[initial_state+1] = 1.0\n\n# Duration of the Ramsey experiment, largest dark time\nT_Ramsey = 10.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_times = 201\nt_dark_times = collect(range(0.0, T_Ramsey, length=N_dark_times))\n\n# Forward solve to generate synthetic data\nrho_synthetic_ramsey_u,rho_synthetic_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t   omegas,omr, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing parameters\n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states\npopulation_synthetic = GLOQ.get_population(rho_synthetic_ramsey_u)","category":"page"},{"location":"example1/#Step-2:-define-the-loss-(objective)-function,-initial-guess-and-optimization-bounds","page":"Example 1","title":"Step 2: define the loss (objective) function, initial guess and optimization bounds","text":"","category":"section"},{"location":"example1/#Step-2a:-define-the-loss-(objective)-function.-Here,-we-use-the-normalized-l2-mismatch.","page":"Example 1","title":"Step 2a: define the loss (objective) function. Here, we use the normalized l2-mismatch.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"function loss(p,dummy_parameter)\n\t# forward solve for Ramsey experiment\n\t_rho_ramsey_u,_rho_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\trho_u0,rho_v0,\n\t\t(2*pi).*[p[1]],omr,\n\t\t[p[2]],[p[3]],#gamma1,gamma2,\n\t\tinitial_state, # initial state\n\t\tTC,t_dark_times,N_states)\n\t_population_ramsey = GLOQ.get_population(_rho_ramsey_u)\n\n\t# compute the mismatch with synthetic data in l2 sense\n\t_loss = sum(abs2,_population_ramsey-population_synthetic)/N_dark_times\n\treturn _loss\nend","category":"page"},{"location":"example1/#Step-2b:-define-a-callback-function-to-plot-while-optimizing","page":"Example 1","title":"Step 2b: define a callback function to plot while optimizing","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"plot_callback = function(p,other_args)\n\trho_ramsey_u,rho_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\trho_u0,rho_v0,\n\t\t(2*pi).*[p[1]],omr,\n\t\t[p[2]],[p[3]],#gamma1,gamma2,\n\t\tinitial_state, # initial state\n\t\tTC,t_dark_times,N_states)\n\t\tpopulation_ramsey = GLOQ.get_population(rho_ramsey_u)\n\tfig=plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\tline = (:dash,0.0), marker = ([:hex :hex], 5, 0.5)  )\n\tplot!(fig,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_ramsey,label=[\"Opt-0\" \"Opt-1\"])\t\t\t\n\tdisplay(fig)\n\treturn false\nend","category":"page"},{"location":"example1/#Step-2c:-define-a-callback-function-to-plot-while-optimizing","page":"Example 1","title":"Step 2c: define a callback function to plot while optimizing","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"p_true = [freqs;gamma1;gamma2] # values to generate synthetic data\n# initial guess for the optimization\np_initial = [freqs.-1e-4;0.9.*gamma1;0.9.*gamma2]\n# bounds for the optimization\nlower_bound = (0.5).*p_true\nupper_bound = (1.5).*p_true","category":"page"},{"location":"example1/#Step-3:-solve-the-optimization-problem","page":"Example 1","title":"Step 3: solve the optimization problem","text":"","category":"section"},{"location":"example1/#Step-3a:-define-the-optimization-object-(objective-function-and-its-gradient)","page":"Example 1","title":"Step 3a: define the optimization object (objective function and its gradient)","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"#  GalacticOptim.OptimizationFunction( objective function, how to compute the gradient ).\n#  Here, we use auto-differentiation with Zygoe to compute the gradient\nloss_gradient = GalacticOptim.OptimizationFunction(loss, GalacticOptim.AutoZygote())\nopt_prob = GalacticOptim.OptimizationProblem(loss_gradient, p_initial,\n\tlb = lower_bound, ub = upper_bound)","category":"page"},{"location":"example1/#Step-3b:-solve-the-optimization-problem-with-the-Optim-interface-of-GalacticOptim","page":"Example 1","title":"Step 3b: solve the optimization problem with the Optim interface of GalacticOptim","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"println(\"Optim Fminbox(LBFGS) Optimization starts\")\n@time sol = GalacticOptim.solve(opt_prob ,Fminbox(LBFGS()),\n\tcb = plot_callback, # call back\n\touter_iterations = 20, # outer iteration number for Optim's fminbox\n\titerations = 10, # inner iteration number for Optim's fminbox\n\tshow_trace=true, # verbose, present optimization infos or not\n\tf_tol = 1e-3,\n\touter_f_tol = 1e-3)\nprintln(\"Optim Fminbox(LBFGS) Optimization done\")","category":"page"},{"location":"example1/#Step-3c:-presnet-the-result","page":"Example 1","title":"Step 3c: presnet the result","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# present the solutions\n# present the solutions\nprintln(\"\\nOptimized results: \",sol.u,\n\t\"\\nLoss: \",sol.minimum,\n\t\"\\nError: \",sol.u-p_true)","category":"page"},{"location":"example1/#Compare-optimized-results-and-the-synthetic-data.","page":"Example 1","title":"Compare optimized results and the synthetic data.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"(Image: Example 1: Optimized results v.s. Synthetic data)","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"The following methods (functions) are exported and available by using GLOQ.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [GLOQ]\nOrder = [:function]","category":"page"},{"location":"methods/#GLOQ.EchoForwardSolve","page":"Methods","title":"GLOQ.EchoForwardSolve","text":"EchoForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.EchoParityForwardSolve","page":"Methods","title":"GLOQ.EchoParityForwardSolve","text":"EchoParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n- \"exponential\": exponential time integrator\n- \"DiffEqDefault\": a default choice made by DifferentialEquations.jl\n- Other solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrhoechou,rhoechov: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.LindbladODEProblem-Tuple{Any,Any,Array{Float64,2},Array{Float64,N} where N,Array{Float64,2},Float64}","page":"Methods","title":"GLOQ.LindbladODEProblem","text":"LindbladODEProblem(rho_u0,L::Array{ComplexF64,2},time_final::Float64;initial_type = \"density\")\n\nFunction provide interfaces to DifferentialEquations package to solve the real-valued Lindblad system: (rho_u - i rho_v)_t = -i (L_K+iL_S)(rho_u-i rho_v) + L_D(rho_u-i rho_v)\n\nArgument:\n\nrho_u0 rho_v0: initial condition rho_0 = rho_u0 - i rho_v0\nLK: real part of the Hamiltonian operator\nLS: imaginary part of the Hamiltonain operator\nLD: Lindblad operator\ntime: final time or time beining evaluated\ninitial_type: specify initial value is a density matrix/a state vector\n\nOutput:\n\nA problem object which we will feed to DifferentialEquations.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.LindbladODEProblemComplex-Tuple{Any,Array{Complex{Float64},2},Float64}","page":"Methods","title":"GLOQ.LindbladODEProblemComplex","text":"LindbladODEProblemComplex(rho0,L::Array{ComplexF64,2},time_final::Float64;initial_type = \"density\")\n\nFunction provide interfaces to DifferentialEquations package to solve: rho_t = L rho\n\nArgument:\n\nL: Lindblad operator\ntime: final time or time beining evaluated\nrho0: initial condition\ninitial_type: specify initial value is a density matrix/a state vector\n\nOutput:\n\nA complex-valued problem object which we will feed to DifferentialEquations.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RamseyForwardSolve","page":"Methods","title":"GLOQ.RamseyForwardSolve","text":"function RamseyForwardSolve(rhou0::Array{Float64},rhov0::Array{Float64}, \t\t\t\t\t\t  omega::Array{Float64},omegadrive::Float64, \t\t\t\t\t\t  gamma1::Array{Float64},gamma2::Array{Float64}, \t\t\t\t\t\t  InitialState::Int64, \t\t\t\t\t\t  TC::Float64,tdarktimes::Array{Float64}, \t\t\t\t\t\t  Nstates::Int64=0; \t\t\t\t\t\t  initial_type=\"states\", \t\t\t\t\t\t  method=\"exponential\", \t\t\t\t\t\t  DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nOutput:\n\nrhoramseyu,rhoramseyv: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.RamseyParityForwardSolve","page":"Methods","title":"GLOQ.RamseyParityForwardSolve","text":"RamseyParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive:Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitalState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;initial_type=\"states\")\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrhoramseyu,rhoramseyv: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.RotationFrameDiagonal-Tuple{Array{Float64,N} where N,Float64}","page":"Methods","title":"GLOQ.RotationFrameDiagonal","text":"RotationFrameDiagonal(omega::Array{Float64},omega_drive::Float64)\n\nArgument:\n\nomega: transition frequencies\nomega_drive: driving frequency\nN: number of states\n\nOutput:\n\nDiagonal matrix diag{0,omega[1]-omr,omega[2]-omr,...,omega[N-1]-omr}\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameLindblad-Tuple{Array{Float64,N} where N,Array{Float64,N} where N}","page":"Methods","title":"GLOQ.RotationFrameLindblad","text":"RotationFrameDiagonal(gamma1::Array{Float64},gamma2::Array{Float64})\n\nArgument:\n\ngamma1: determine the decay operator in the Lindblad system\ngamma2: determine the dephasing operator in the Lindblad system\n\nOutput:\n\nLdecay: Ldecay[i][i+1] = sqrt(gamma1[i]), and zeros everywhere else\nL_dephase: Diagonal{0,sqrt(gamma2[1]),...)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameRamseyControl-Tuple{Float64,Float64,Int64}","page":"Methods","title":"GLOQ.RotationFrameRamseyControl","text":"RotationFrameRamseyControl(abs_control::Float64,phase_control::Float64,N::Int64)\n\nArgument:\n\nabs_control: strength of the control Omega\nphase_control: phase of the control signal theta\nN: number of states\n\nOutput:\n\nHCK,HCS: the real and imaginary part of the control operator, determined by p(a+a^dagger)+iq(a-a^dagger) where a is the lowering operator, p=Omegacos(theta) and q=Omegasin(theta)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameRamseyControl-Tuple{Int64}","page":"Methods","title":"GLOQ.RotationFrameRamseyControl","text":"RotationFrameRamseyControl(N::Int64)\n\nArgument:\n\nabs_control: strength of the control Omega\nphase_control: phase of the control signal theta\nN: number of states\n\nOutput:\n\nHCK,HCS: the real and imaginary part of the control operator, determined by (a+a^dagger)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.T1ForwardSolve","page":"Methods","title":"GLOQ.T1ForwardSolve","text":"T1ForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\n\nOutput:\n\nrhoechou,rhoechov: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.T1ParityForwardSolve","page":"Methods","title":"GLOQ.T1ParityForwardSolve","text":"T1ParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n- \"exponential\": exponential time integrator\n- \"DiffEqDefault\": a default choice made by DifferentialEquations.jl\n- Other solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrhoechou,rhoechov: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.about-Tuple{}","page":"Methods","title":"GLOQ.about","text":"About GLOQ.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.convert_state_to_density-Tuple{Array{Float64,1},Array{Float64,1}}","page":"Methods","title":"GLOQ.convert_state_to_density","text":"convert_state_to_density(u::Array{Float64,1},v::Array{Float64,1})\n\nArgument:\n\nstate vector: u-iv\n\nOutput:\n\nvectorized density matrix: rhou-i rhov\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.exponential_solver","page":"Methods","title":"GLOQ.exponential_solver","text":"exponential_solver_complex(rho_vec0,L,t_span::Array{Float64};initial_type = \"density\"):\n\nPurpose:\n\nuse an exponential integrator to integrate\nrho_t=-i(L_K+iL_S) rho+L_D  ho\n\nArgument:\n\nrho_u0rho_v0: rho0 =\\rho{u0} - i \\rho{v0}``\nLK: real part of the Hamiltonian operator\nLS: imaginary part of the Hamiltonain operator\nLD: Lindblad operator\nt_span: where the solution will be stored\ninitial_type: \"density\" vectorized density matrix, \"states\" states vector\n\nOutput:\n\nrhou,rhov: solutions at tspan given by ``\\rho(ti) =  hou(:,i)-i  hov(:,i)``\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.exponential_solver_complex-Tuple{Any,Any,Array{Float64,N} where N}","page":"Methods","title":"GLOQ.exponential_solver_complex","text":"exponential_solver_complex(rho_vec0,L,t_span::Array{Float64};initial_type = \"density\"):\n\nArgument:\n\nL: the whole propagation operator\nt_span: where the function will be evaluated stored in\nrho0_vec: initial density/state\ninitial_type: decide we aer given an initial density matrix or a state vector\n\nOutput:\n\nsolutions at t_span\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.exponential_solver_complex-Tuple{Any,Any,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}","page":"Methods","title":"GLOQ.exponential_solver_complex","text":"exponential_solver(rho_vec0,L,t_span::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}};\n                   initial_type = \"density\")\n\nArgument:\n\nL: the whole propagation operator\nt_span: where the function will be evaluated stored in\nrho0_vec: initial density/state\ninitial_type: decide we aer given an initial density matrix or a state vector\n\nOutput:\n\nComplex-valued solutions at t_span\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Complex{Float64},1}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(rho_vec::Array{ComplexF64,1})\n\nArgument:\n\nrho_vec, density matrix in the vector form\n\nOutput:\n\nthe population in an array\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Complex{Float64},2}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(rho_vec_history::Array{ComplexF64,2})\n\nArgument:\n\nrhovechistory, time history for the vectorized density matrix,\n\ni-th column corresponding to the i-th time point\n\nOutput:\n\nThe population history P which is a 2D array, P[i,j] is corresponding\n\nto time point i and state j\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Float64,2}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(rho_vec_history::Array{Float64,2})\n\nArgument:\n\nrhouhistory: time history for the vectorized density matrix, j-th column corresponding to the j-th time point\n\nrhohistory = rhouhistory - i rhov_history.\n\nSince the density matrix should be Hermitian, it is good enough to just have the real part.\n\nOutput:\n\nThe population history P which is a 2D array, P[i,j] is corresponding\n\nto time point i and state j\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.hello_world-Tuple{}","page":"Methods","title":"GLOQ.hello_world","text":"hello_world():\n\nA hello world function\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.make_hamiltonian_operator","page":"Methods","title":"GLOQ.make_hamiltonian_operator","text":"make_Hamiltonian_operator(HK,HS,N::Int64=0)\n\nArgument:\n\nThe real part and the imaginary part of the Hamiltonian: H = H_K-i H_S\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLK: real matrix corresponding to the real part of the Hamiltonian operator\nLS: real matrix corresponding to the imaginary part of the Hamiltonian operator\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.make_lindblad_operator","page":"Methods","title":"GLOQ.make_lindblad_operator","text":"make_lindblad_operator(HK,HS,L_list,N::Int64=0)\n\nArgument:\n\nThe real part and the imaginary part of the Hamiltonian: H = H_K-i H_S\nA list of Lindblad terms L_k's\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLK: real matrix corresponding to the real part of the Hamiltonian operator\nLS: real matrix corresponding to the imaginary part of the Hamiltonian operator\nLD: real matrix corresponding to the Lindblad operator\nFinal system: rho_t = -i(L_K+i L_S)rho+L_D rho\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.make_lindblad_operator_complex","page":"Methods","title":"GLOQ.make_lindblad_operator_complex","text":"make_lindblad_operator(H,L_list,N::Int64=0)\n\nArgument:\n\nthe Hamiltonain H and a list of Lindblad terms L_k's\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLH: complex matrix corresponding to the Hamiltonian operator\nLD: complex matrix corresponding to the Lindblad operator\n\n\n\n\n\n","category":"function"},{"location":"#GLOQ.jl","page":"Home","title":"GLOQ.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GLOQ.jl","category":"page"},{"location":"function-index/","page":"Index","title":"Index","text":"Modules = [GLOQ]","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The following types are exported and available by using GLOQ.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [GLOQ]\nOrder = [:type]","category":"page"}]
}
