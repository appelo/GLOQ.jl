var documenterSearchIndex = {"docs":
[{"location":"example2/#Example-2:-characterization-of-the-Ramsey-experiment,-Echo-experiment-and-T1-decay-experiment-with-single-qudit","page":"Example 2","title":"Example 2: characterization of the Ramsey experiment, Echo experiment and T1-decay experiment with single qudit","text":"","category":"section"},{"location":"example2/#Step-1:-generate-the-synthetic-data","page":"Example 2","title":"Step 1: generate the synthetic data","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# System parameters for a simple two level open quantum system\nN_states = 2; # number of states\nfreqs = [4.1] # transition frequency in GHz\nomegas = 2.0*pi.*freqs # change to angular frequency\ngamma1   = [25e-05] # decay\ngamma2   = [25e-05] # dephasing\nomr_ramsey = 2.0*pi*(4.1 - 1.0e-3) # drive frequency for the Ramsey experiment\nomr_echo = 2.0*pi*4.1  # drive frequency for the Echo experiment\nomr_t1 = 2.0*pi*4.1  # drive frequency for the T1 experiment\nTC = 2.5*17.0 # total control time\n\n# Initial state\ninitial_state = 0\nrho_u0 = [0.0;0.0]\nrho_v0 = [0.0;0.0]\nrho_u0[initial_state+1] = 1.0\n\n# Duration of the Ramsey experiment, largest dark time\nT_Ramsey = 10.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_times = 201\nt_dark_times = collect(range(0.0, T_Ramsey, length=N_dark_times))\n","category":"page"},{"location":"example2/#Forward-solve-to-generate-synthetic-data","page":"Example 2","title":"Forward solve to generate synthetic data","text":"","category":"section"},{"location":"example2/#Ramsey-experiment","page":"Example 2","title":"Ramsey experiment","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"rho_synthetic_ramsey_u,rho_synthetic_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr_ramsey, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states\npopulation_ramsey_synthetic = GLOQ.get_population(rho_synthetic_ramsey_u)","category":"page"},{"location":"example2/#Echo-experiment","page":"Example 2","title":"Echo experiment","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"rho_synthetic_echo_u,rho_synthetic_echo_v = GLOQ.EchoForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr_echo, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states\npopulation_echo_synthetic = GLOQ.get_population(rho_synthetic_echo_u)","category":"page"},{"location":"example2/#T1-decay-experiment","page":"Example 2","title":"T1-decay experiment","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"rho_synthetic_t1_u,rho_synthetic_t1_v = GLOQ.T1ForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr_t1, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing \n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states\npopulation_t1_synthetic = GLOQ.get_population(rho_synthetic_t1_u)\n","category":"page"},{"location":"example2/#Step-2:-define-the-loss-(objective)-function,-initial-guess-and-optimization-bounds","page":"Example 2","title":"Step 2: define the loss (objective) function, initial guess and optimization bounds","text":"","category":"section"},{"location":"example2/#Step-2a:-define-the-loss-(objective)-function.-Here,-we-use-the-normalized-l2-mismatch.","page":"Example 2","title":"Step 2a: define the loss (objective) function. Here, we use the normalized l2-mismatch.","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# Define the loss function for the GalacticOptim\n# p: phyiscal parameters:\n#\t p[1] = transition frequency in GHz\n#    p[2] = gamma1\n#    p[3] = gamma2\n# dummy_parameter: needed by GalacticOptim, one can just put [] here\nfunction loss(p,dummy_parameter)\n\t# Ramsey\n\t_rho_ramsey_u,_rho_ramsey_v = GLOQ.RamseyForwardSolve(rho_u0,rho_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_ramsey,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\t_population_ramsey = GLOQ.get_population(_rho_ramsey_u)\n\t# Echo\n    _rho_echo_u,_rho_echo_v = GLOQ.EchoForwardSolve(rho_u0,rho_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_echo,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\t_population_echo = GLOQ.get_population(_rho_echo_u)\n\t# T1\n    _rho_t1_u,_rho_t1_v = GLOQ.T1ForwardSolve(rho_u0,rho_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_t1,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\t_population_t1 = GLOQ.get_population(_rho_t1_u)\n\n\t_loss = ( sum(abs2,_population_ramsey-population_ramsey_synthetic)+\n\t\t\t  sum(abs2,_population_echo-population_echo_synthetic)+\n\t\t\t  sum(abs2,_population_t1-population_t1_synthetic) )/N_dark_times\n\t\t\n\treturn _loss#,_population_ramsey\nend\n","category":"page"},{"location":"example2/#Step-2b:-define-a-callback-function-to-plot-while-optimizing","page":"Example 2","title":"Step 2b: define a callback function to plot while optimizing","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"plot_callback = function(p,other_args)\n\t# Ramsey\n\trho_ramsey_u,rho_ramsey_v = GLOQ.RamseyForwardSolve(rho_u0,rho_v0,\n\t\t\t\t\t (2*pi).*[p[1]],omr_ramsey,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\tpopulation_ramsey = GLOQ.get_population(rho_ramsey_u)\n\t# Echo\n    rho_echo_u,rho_echo_v = GLOQ.EchoForwardSolve(rho_u0,rho_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_echo,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\tpopulation_echo = GLOQ.get_population(rho_echo_u)\n\n\t# T1\n    rho_t1_u,rho_t1_v = GLOQ.T1ForwardSolve(rho_u0,rho_v0,\n\t\t\t\t     (2*pi).*[p[1]],omr_t1,\n\t\t\t\t\t [p[2]],[p[3]],#gamma1,gamma2,\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states)\n\tpopulation_t1 = GLOQ.get_population(rho_t1_u)\n\n\t# Plot\n\t# Ramsey\n\tfig_ramsey = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_ramsey_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\t\t\t          line = (:dash,0.0), marker = ([:hex :hex], 5, 0.5),legend=:outerright,\n\t\t\t\t\t  title=\"Ramsey\");\n\tplot!(fig_ramsey,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_ramsey,label=[\"Opt-0\" \"Opt-1\"],legend=:outerright);\n\t# Echo\n\tfig_echo = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_echo_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\t\t  \t\t     line = (:dash,0.0), marker = ([:hex :hex], 5, 0.5),legend=:outerright,\n\t\t\t\t\t title=\"Echo\");\n\tplot!(fig_echo,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_echo,label=[\"Opt-0\" \"Opt-1\"],legend=:outerright);\t\t\n\t# T1\n\tfig_t1=plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_t1_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\t\t\t    line = (:dash,0.0), marker = ([:hex :hex], 5, 0.5),legend=:outerright,\n\t\t\t\ttitle=\"T1\");\n\tplot!(fig_t1,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_t1,label=[\"Opt-0\" \"Opt-1\"],legend=:outerright);\n\n\tdisplay( plot(fig_ramsey,fig_echo,fig_t1,layout=grid(3,1),size=[1000,1500],\n\t\t\t\t  legendfontsize=15,xtickfontsize=15,ytickfontsize=15,titlefontsize=18) )\n\treturn false\nend\n","category":"page"},{"location":"example2/#Step-2c:-define-the-initial-guess-for-the-optimization","page":"Example 2","title":"Step 2c: define the initial guess for the optimization","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"p_true = [freqs;gamma1;gamma2] # values to generate synthetic data\n# initial guess for the optimization\np_initial = [freqs.-2e-4;0.75.*gamma1;1.25.*gamma2]\n# bounds for the optimization\nlower_bound = (0.5).*p_true\nupper_bound = (1.5).*p_true\n","category":"page"},{"location":"example2/#Step-3:-solve-the-optimization-problem","page":"Example 2","title":"Step 3: solve the optimization problem","text":"","category":"section"},{"location":"example2/#Step-3a:-define-the-optimization-object-(objective-function-and-its-gradient)","page":"Example 2","title":"Step 3a: define the optimization object (objective function and its gradient)","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"# construct optimization object, use Zygote auto-differentiation to compute the gradient\nloss_gradient = GalacticOptim.OptimizationFunction(loss, GalacticOptim.AutoZygote())\nopt_prob = GalacticOptim.OptimizationProblem(loss_gradient, p_initial,\n\t\t\t\t\t\t\t\t\t\t lb = lower_bound, ub = upper_bound)\n\n","category":"page"},{"location":"example2/#Step-3b:-solve-the-optimization-problem-with-the-Optim-interface-of-GalacticOptim","page":"Example 2","title":"Step 3b: solve the optimization problem with the Optim interface of GalacticOptim","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"println(\"Optim Fminbox(LBFGS) Optimization starts\")\n@time sol = GalacticOptim.solve(opt_prob ,Fminbox(LBFGS()),\n\t\t\t\t\t\t\t\tcb = plot_callback,\n\t\t\t\t\t\t\t\touter_iterations = 20,\n\t\t\t\t\t\t\t\titerations = 10,\n\t\t\t\t\t\t\t\tshow_trace=true,\n\t\t\t\t\t\t\t\tf_tol = 1e-3,\n\t\t\t\t\t\t\t\touter_f_tol = 1e-3)\nprintln(\"Optim Fminbox(LBFGS) Optimization done\")\n","category":"page"},{"location":"example2/#Step-3c:-presnet-the-result","page":"Example 2","title":"Step 3c: presnet the result","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"println(\"\\nOptimized results: \",sol.u,\n        \"\\nLoss: \",sol.minimum,\n\t\t\"\\nError: \",sol.u-p_true)\n","category":"page"},{"location":"example2/#Optimized-results-v.s.-Synthetic-data","page":"Example 2","title":"Optimized results v.s. Synthetic data","text":"","category":"section"},{"location":"example2/","page":"Example 2","title":"Example 2","text":"(Image: Example 2: Optimized results v.s. Synthetic data)","category":"page"},{"location":"example3/#Example-3:-uncertainty-quantification-for-a-single-qubit-Ramsey-experiment-with-noise-with-the-Metropolis-Hastings-algorithm","page":"Example 3","title":"Example 3: uncertainty quantification for a single qubit Ramsey experiment with noise with the Metropolis-Hastings algorithm","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"using LinearAlgebra\nusing Turing, Distributions, DifferentialEquations\n# Import MCMCChain, Plots, and StatsPlots for visualizations and diagnostics.\nusing MCMCChains, Plots, StatsPlots\nusing CSV,DataFrames\n# Set a seed for reproducibility.\nusing Random\nRandom.seed!(14);\nusing Plots\ninclude(\"../src/GLOQ.jl\")\npyplot()","category":"page"},{"location":"example3/#Step-1:-generate-the-synthetic-data","page":"Example 3","title":"Step 1: generate the synthetic data","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"N_states = 2; # number of states\nfreqs = [4.1] # transition frequency in GHz\nomegas = 2.0*pi.*freqs # change to angular frequency\ngamma1   = [25e-05] # decay\ngamma2   = [25e-05] # dephasing\nomr = 2.0*pi*(4.1 - 1.0e-3) # drive frequency\nTC = 2.5*17.0 # total control time\n\n# Initial state\ninitial_state = 0\nrho_u0 = [0.0;0.0]\nrho_v0 = [0.0;0.0]\nrho_u0[initial_state+1] = 1.0\n\n# Duration of the Ramsey experiment, largest dark time\nT_Ramsey = 5.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_times = 101\nt_dark_times = collect(range(0.0, T_Ramsey, length=N_dark_times))","category":"page"},{"location":"example3/#Forward-solve-to-generate-synthetic-data","page":"Example 3","title":"Forward solve to generate synthetic data","text":"","category":"section"},{"location":"example3/#Ramsey-experiment","page":"Example 3","title":"Ramsey experiment","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"rho_synthetic_ramsey_u,rho_synthetic_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t     omegas,omr, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing parameters ?\n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states\npopulation_synthetic = GLOQ.get_population(rho_synthetic_ramsey_u)","category":"page"},{"location":"example3/#Add-multiplicative-and-additive-noise-to-the-synthetic-data","page":"Example 3","title":"Add multiplicative and additive noise to the synthetic data","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"noisy_data = copy(population_synthetic)\nmultiplicative_noise = 1.0.+0.05*randn(N_dark_times) # 0.01\nnoisy_data .*= multiplicative_noise\nadditive_noise = 0.05*randn(N_dark_times) # 0.025\nnoisy_data .+= additive_noise","category":"page"},{"location":"example3/#Normalize-the-nosiy-data-so-that-it-is-a-population-between-[0,1]","page":"Example 3","title":"Normalize the nosiy data so that it is a population between [0,1]","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"for j = 1:N_states\n\tshift = minimum(noisy_data[:,j])\n\tif(shift<0.0)\n\t\tnoisy_data[:,j] .-= shift\n\tend\nend\n\nfor i = 1:N_dark_times\n\tnoisy_data[i,:] ./= sum(noisy_data[i,:])\nend","category":"page"},{"location":"example3/#Plot-the-noisy-data","page":"Example 3","title":"Plot the noisy data","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"fig = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_synthetic,\n\t\t   label=[\"Syn-0\" \"Syn-1\"])\nscatter!(fig,t_dark_times./GLOQ.GLOQ_MICRO_SEC,noisy_data,\n\t\t label=[\"Noisy-0\" \"Noisy-1\"])\n\np_true = [freqs;gamma1;gamma2]","category":"page"},{"location":"example3/#Synthetic-data-with-and-without-noise","page":"Example 3","title":"Synthetic data with and without noise","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: synthetic noisy data)","category":"page"},{"location":"example3/#Step-2:-define-the-model-interface-to-the-Turing.jl-and-apply-the-MCMC-algorithm","page":"Example 3","title":"Step 2: define the model interface to the Turing.jl and apply the MCMC algorithm","text":"","category":"section"},{"location":"example3/#Step-2a:-define-the-model","page":"Example 3","title":"Step 2a: define the model","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"global sample_number\n@model function RamseyExperiment(data)\n\t # Priori distribution\n\tσ ~ InverseGamma()\n    _freq ~ truncated(Normal(4.1,1e-4),4.1-5e-4,4.1+5e-4)\n    _gamma1 ~ truncated(Normal(25e-05,1e-5),20e-5,30e-5)\n    _gamma2 ~ truncated(Normal(25e-05,1e-5),20e-5,30e-5)\n\n\t_rho_ramsey_u,_rho_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t\t     2.0*pi*[_freq],omr, # transition frequencies, drive frequency\n\t\t\t\t\t [_gamma1],[_gamma2], # decay and dephasing parameters ?\n\t\t\t\t\t initial_state, # initial state\n\t\t\t\t\t TC,t_dark_times,N_states;\n\t\t\t\t\t method=\"exponential\")\n\t\t\t\t\t #method = Trapezoid()) # control time, dark time, total number of states\n\t_population_ramsey = GLOQ.get_population(_rho_ramsey_u)\n\tfor i = 1:N_dark_times\n        data[i,:] ~ MvNormal(_population_ramsey[i,:], σ)\n    end\n\tglobal sample_number\n\tsample_number += 1\n\tprintln(\"Sample \",sample_number,\" done\")\nend\n\nmodel = RamseyExperiment(noisy_data)","category":"page"},{"location":"example3/#Step-2b:-apply-the-Metropolis-Hastings-algorithm","page":"Example 3","title":"Step 2b: apply the Metropolis-Hastings algorithm","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"sample_number = 0\nchain_size = 35000\n@time chain = sample(model, MH(Diagonal([5e-3,5e-3,5e-2,5e-2])), chain_size)\nBurnIn = 5000\n#@time chain_gmh = sample(model, Gibbs(MH()),5000)\ndisplay(plot(chain[BurnIn+1:end]))\ndisplay(chain[BurnIn+1:end])","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: chain)","category":"page"},{"location":"example3/#Step-3:-Present-the-data","page":"Example 3","title":"Step 3: Present the data","text":"","category":"section"},{"location":"example3/#Step-3a:-convert-the-data-to-DataFrame-format-and-calculate-the-mean-value-of-the-Markov-chain","page":"Example 3","title":"Step 3a: convert the data to DataFrame format and calculate the mean value of the Markov chain","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"chain_data = DataFrame(chain[BurnIn+1:end])\nfreq_mean = mean(chain_data._freq)\ngamma1_mean = mean(chain_data._gamma1)\ngamma2_mean = mean(chain_data._gamma2)","category":"page"},{"location":"example3/#The-Ramsey-curve-corresponding-to-the-mean-value-of-the-chain","page":"Example 3","title":"The Ramsey curve corresponding to the mean value of the chain","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"rho_chain_mean_u,rho_chain_mean_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t\t 2.0*pi*[freq_mean],omr, # transition frequencies, drive frequency\n\t\t\t\t [gamma1_mean],[gamma2_mean], # decay and dephasing parameters ?\n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states;\n\t\t\t\t method=\"exponential\")\npopulation_chain_mean = GLOQ.get_population(rho_chain_mean_u)\nfig_mean_vs_noisy = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_chain_mean,\n\t\t   \t\t  label=[\"Mean-0\" \"Mean-1\"])\nscatter!(fig_mean_vs_noisy,t_dark_times./GLOQ.GLOQ_MICRO_SEC,noisy_data,\n\t\t label=[\"Noisy data-0\" \"Noisy data-1\"])\ndisplay(fig_mean_vs_noisy)","category":"page"},{"location":"example3/#The-Ramsey-curve-corresponding-to-the-mean-value-vs-data-with-noise","page":"Example 3","title":"The Ramsey curve corresponding to the mean value vs data with noise","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: mean value vs noisy data)","category":"page"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"fig_mean_vs_syn = plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_chain_mean,\n\t\t\t\t   label=[\"Mean-0\" \"Mean-1\"])\nscatter!(fig_mean_vs_syn,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_synthetic,\n\t\t label=[\"Syn-0\" \"Syn-1\"])\ndisplay(fig_mean_vs_syn)","category":"page"},{"location":"example3/#The-Ramsey-curve-corresponding-to-the-mean-value-vs-data-without-noise","page":"Example 3","title":"The Ramsey curve corresponding to the mean value vs data without noise","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: mean value vs data without noise)","category":"page"},{"location":"example3/#Display-the-difference-between-the-mean-value-of-the-chain-and-the-true-value","page":"Example 3","title":"Display the difference between the mean value of the chain and the true value","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"println( \"Error of freqs: \",abs(freq_mean-freqs[1]),\n\t\t \" Error of γ₁: \",abs(gamma1_mean-gamma1[1]),\n\t\t \" Error of γ₂: \",abs(gamma2_mean-gamma2[1]) )","category":"page"},{"location":"example3/#Results:","page":"Example 3","title":"Results:","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"Error of freqs: 3.7845511347001093e-7 Error of γ₁: 4.406514689200315e-7 Error of γ₂: 8.2938489833124e-7","category":"page"},{"location":"example3/#Sample-from-the-Markov-chain-and-perform-forward-solves","page":"Example 3","title":"Sample from the Markov chain and perform forward solves","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"global fig_result\nfor i = 1:1000\n\tglobal fig_result\n\tsample_ind = rand(1:chain_size-BurnIn)\n    freq_sample = chain_data._freq[sample_ind]\n    gamma1_sample = chain_data._gamma1[sample_ind]\n    gamma2_sample = chain_data._gamma2[sample_ind]\n    rho_sample_u,rho_sample_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t\t 2.0*pi*[freq_sample],omr, # transition frequencies, drive frequency\n\t\t\t\t [gamma1_sample],[gamma2_sample], # decay and dephasing parameters ?\n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states;\n\t\t\t\t method=\"exponential\")\n    population_sample = GLOQ.get_population(rho_sample_u)\n\tif (i==1)\n    \tfig_result=plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_sample,\n              color = \"#BBBBBB\", label=\"\");\n\telse\n    \tplot!(fig_result,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_sample,\n              color = \"#BBBBBB\", label=\"\");\n\tend\nend\nplot!(fig_result,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_chain_mean,\n\t  linewidth=1.0,label=[\"Mean-0\" \"Mean-1\"])\nscatter!(fig_result,t_dark_times./GLOQ.GLOQ_MICRO_SEC,noisy_data,\n\t     label=[\"Noisy data-0\" \"Noisy data-1\"])\ndisplay(fig_result)","category":"page"},{"location":"example3/#The-Ramsey-curves-based-on-parameter-samples-from-the-posteriori-distribution","page":"Example 3","title":"The Ramsey curves based on parameter samples from the posteriori distribution","text":"","category":"section"},{"location":"example3/","page":"Example 3","title":"Example 3","text":"(Image: Example 3: the Ramsey results corresponding to the posterior distribution and the mean results)","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The work flow for solving a quantum characterization problem consists of the following general steps:","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Setup\nOptimize","category":"page"},{"location":"workflow/#.-Setup","page":"Workflow","title":"1. Setup","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"The setup phase includes specifying","category":"page"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Load the experimental/synthetic data\nSpecify the known parameters\nNumber of the states\nSet up initial guess and the bounds for target parameters\nCreate the loss (objective) function by fitting the data set with forward solves\nOptional: compute/approximate the Jacobian of the loss function. By default, auto-differentiation (Zygote.jl) or finite-difference approxiamtion will be used.","category":"page"},{"location":"workflow/#.-Optimization","page":"Workflow","title":"2. Optimization","text":"","category":"section"},{"location":"workflow/","page":"Workflow","title":"Workflow","text":"Feed the loss function and its Jacobian to the interface of optimization package.","category":"page"},{"location":"model/#Lindblad-equation","page":"Model","title":"Lindblad equation","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"We consider the N energy level Lindblad equation:","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"beginequation\ndotrho = -ileft(Hrho - rho Hright) + sum_j=1^2 left( cal L_j rho cal L_j^dagger -\nfrac12left( cal L_j^daggercal L_jrho + rhocal L_j^daggercal L_j right) right)\nendequation","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"Here, rho(t) is the density matrix, H(t) is a Hamiltonain operator, and operators cal L_1 and cal L_2 model the decay and dephasing mechanisim.","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"By default, the Hamiltonian is in the form of H(t)=H_rm 0+H_c(t), where","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"H_rm 0 = left\nbeginarraycccc\n0         \n   omega_01     \n      omega_01 + omega_12    \n         ddots   \n                  sum_k=0^N-1omega_N-1N\nendarray\nright","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"is the system Hamiltonian, and H_c(t) is the control Hamiltonian. The decay operator cal L_1 is in the form ","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"cal L_1 = left\nbeginarraycccc\n0  sqrtgamma_11      \n   0  sqrtgamma_12    \n      ddots  ddots   \n            0  sqrtgamma_1N-1 \n                0\nendarrayright","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"and the dephasing operator cal L_2 is in the form ","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"cal L_2 = left\nbeginarraycccc\n0          \n   sqrtgamma_21        \n      sqrtgamma_22     \n          ddots   \n                   sqrtgamma_2N-1\nendarray\nright","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"The T_1 relaxation time for energy level k is T_1k=1gamma_1k, and the T_2 dephasing time for energy level k is T_2k=1gamma_2k.","category":"page"},{"location":"model/#Lindblad-equation-with-charge-noise","page":"Model","title":"Lindblad equation with charge noise","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"We also consider the Lindblad model with noise. The system Hamiltonian is","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"H_rm 0 = left\nbeginarraycccc\n0         \n   widetildeomega_01     \n      widetildeomega_01 + widetildeomega_12    \n         ddots   \n                  sum_k=0^N-1widetildeomega_N-1N\nendarray\nright","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"and  widetildeomega_kk+1=omega_kk+1-pi d_kk+1cosleft(pifracC+peeright) Here, pin01 is the parity, d_kk+1 is the charge dispersion, C is the charge over the Josephson junction, e is the charge of an electron, and fracCein01.","category":"page"},{"location":"model/","page":"Model","title":"Model","text":"For now, we neglect the charge noise due to the charge event (the effect of Ce) and only consider the charge noise due to the parity event (the effect of p).  In the numerical simulation, we take the average of the forward solve of the deterministic Lindblad equation with p=0 and p=1. ","category":"page"},{"location":"example1/#Example-1:-characterization-of-the-Ramsey-experiment-with-single-qudit","page":"Example 1","title":"Example 1: characterization of the Ramsey experiment with single qudit","text":"","category":"section"},{"location":"example1/#Step-1:-generate-the-synthetic-data","page":"Example 1","title":"Step 1: generate the synthetic data","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# System parameters for a simple two level open quantum system\nN_states = 2; # number of states\nfreqs = [4.1] # transition frequency in GHz\nomegas = 2.0*pi.*freqs # change to angular frequency\ngamma1   = [25e-05] # decay???\ngamma2   = [25e-05] # dephasing???\nomr = 2.0*pi*(4.1 - 1.0e-3) # drive frequency\nTC = 2.5*17.0 # total control time\n\n# Initial state\ninitial_state = 0\nrho_u0 = [0.0;0.0]\nrho_v0 = [0.0;0.0]\nrho_u0[initial_state+1] = 1.0\n\n# Duration of the Ramsey experiment, largest dark time\nT_Ramsey = 10.0*GLOQ.GLOQ_MICRO_SEC # convert micro-sec to nano-sec\n# total number of dark time samples\nN_dark_times = 201\nt_dark_times = collect(range(0.0, T_Ramsey, length=N_dark_times))\n\n# Forward solve to generate synthetic data\nrho_synthetic_ramsey_u,rho_synthetic_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\t\t\t rho_u0,rho_v0, # initial values, u for the real part, v for the imaginary part\n\t\t\t   omegas,omr, # transition frequencies, drive frequency\n\t\t\t\t gamma1,gamma2, # decay and dephasing parameters\n\t\t\t\t initial_state, # initial state\n\t\t\t\t TC,t_dark_times,N_states) # control time, dark time, total number of states\npopulation_synthetic = GLOQ.get_population(rho_synthetic_ramsey_u)","category":"page"},{"location":"example1/#Step-2:-define-the-loss-(objective)-function,-initial-guess-and-optimization-bounds","page":"Example 1","title":"Step 2: define the loss (objective) function, initial guess and optimization bounds","text":"","category":"section"},{"location":"example1/#Step-2a:-define-the-loss-(objective)-function.-Here,-we-use-the-normalized-l2-mismatch.","page":"Example 1","title":"Step 2a: define the loss (objective) function. Here, we use the normalized l2-mismatch.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"function loss(p,dummy_parameter)\n\t# forward solve for Ramsey experiment\n\t_rho_ramsey_u,_rho_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\trho_u0,rho_v0,\n\t\t(2*pi).*[p[1]],omr,\n\t\t[p[2]],[p[3]],#gamma1,gamma2,\n\t\tinitial_state, # initial state\n\t\tTC,t_dark_times,N_states)\n\t_population_ramsey = GLOQ.get_population(_rho_ramsey_u)\n\n\t# compute the mismatch with synthetic data in l2 sense\n\t_loss = sum(abs2,_population_ramsey-population_synthetic)/N_dark_times\n\treturn _loss\nend","category":"page"},{"location":"example1/#Step-2b:-define-a-callback-function-to-plot-while-optimizing","page":"Example 1","title":"Step 2b: define a callback function to plot while optimizing","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"plot_callback = function(p,other_args)\n\trho_ramsey_u,rho_ramsey_v = GLOQ.RamseyForwardSolve(\n\t\trho_u0,rho_v0,\n\t\t(2*pi).*[p[1]],omr,\n\t\t[p[2]],[p[3]],#gamma1,gamma2,\n\t\tinitial_state, # initial state\n\t\tTC,t_dark_times,N_states)\n\t\tpopulation_ramsey = GLOQ.get_population(rho_ramsey_u)\n\tfig=plot(t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_synthetic,label=[\"Syn-0\" \"Syn-1\"],\n\tline = (:dash,0.0), marker = ([:hex :hex], 5, 0.5)  )\n\tplot!(fig,t_dark_times./GLOQ.GLOQ_MICRO_SEC,population_ramsey,label=[\"Opt-0\" \"Opt-1\"])\t\t\t\n\tdisplay(fig)\n\treturn false\nend","category":"page"},{"location":"example1/#Step-2c:-define-a-callback-function-to-plot-while-optimizing","page":"Example 1","title":"Step 2c: define a callback function to plot while optimizing","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"p_true = [freqs;gamma1;gamma2] # values to generate synthetic data\n# initial guess for the optimization\np_initial = [freqs.-1e-4;0.9.*gamma1;0.9.*gamma2]\n# bounds for the optimization\nlower_bound = (0.5).*p_true\nupper_bound = (1.5).*p_true","category":"page"},{"location":"example1/#Step-3:-solve-the-optimization-problem","page":"Example 1","title":"Step 3: solve the optimization problem","text":"","category":"section"},{"location":"example1/#Step-3a:-define-the-optimization-object-(objective-function-and-its-gradient)","page":"Example 1","title":"Step 3a: define the optimization object (objective function and its gradient)","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"#  GalacticOptim.OptimizationFunction( objective function, how to compute the gradient ).\n#  Here, we use auto-differentiation with Zygoe to compute the gradient\nloss_gradient = GalacticOptim.OptimizationFunction(loss, GalacticOptim.AutoZygote())\nopt_prob = GalacticOptim.OptimizationProblem(loss_gradient, p_initial,\n\tlb = lower_bound, ub = upper_bound)","category":"page"},{"location":"example1/#Step-3b:-solve-the-optimization-problem-with-the-Optim-interface-of-GalacticOptim","page":"Example 1","title":"Step 3b: solve the optimization problem with the Optim interface of GalacticOptim","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"println(\"Optim Fminbox(LBFGS) Optimization starts\")\n@time sol = GalacticOptim.solve(opt_prob ,Fminbox(LBFGS()),\n\tcb = plot_callback, # call back\n\touter_iterations = 20, # outer iteration number for Optim's fminbox\n\titerations = 10, # inner iteration number for Optim's fminbox\n\tshow_trace=true, # verbose, present optimization infos or not\n\tf_tol = 1e-3,\n\touter_f_tol = 1e-3)\nprintln(\"Optim Fminbox(LBFGS) Optimization done\")","category":"page"},{"location":"example1/#Step-3c:-presnet-the-result","page":"Example 1","title":"Step 3c: presnet the result","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"# present the solutions\n# present the solutions\nprintln(\"\\nOptimized results: \",sol.u,\n\t\"\\nLoss: \",sol.minimum,\n\t\"\\nError: \",sol.u-p_true)","category":"page"},{"location":"example1/#Compare-optimized-results-and-the-synthetic-data.","page":"Example 1","title":"Compare optimized results and the synthetic data.","text":"","category":"section"},{"location":"example1/","page":"Example 1","title":"Example 1","text":"(Image: Example 1: Optimized results v.s. Synthetic data)","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"The following methods (functions) are exported and available by using GLOQ.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [GLOQ]\nOrder = [:function]","category":"page"},{"location":"methods/#GLOQ.EchoForwardSolve","page":"Methods","title":"GLOQ.EchoForwardSolve","text":"EchoForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.EchoParityForwardSolve","page":"Methods","title":"GLOQ.EchoParityForwardSolve","text":"EchoParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n- \"exponential\": exponential time integrator\n- \"DiffEqDefault\": a default choice made by DifferentialEquations.jl\n- Other solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrhoechou,rhoechov: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.LindbladODEProblem-Tuple{Any,Any,Array{Float64,2},Array{Float64,N} where N,Array{Float64,2},Float64}","page":"Methods","title":"GLOQ.LindbladODEProblem","text":"LindbladODEProblem(rho_u0,L::Array{ComplexF64,2},time_final::Float64;initial_type = \"density\")\n\nFunction provide interfaces to DifferentialEquations package to solve the real-valued Lindblad system: (rho_u - i rho_v)_t = -i (L_K+iL_S)(rho_u-i rho_v) + L_D(rho_u-i rho_v)\n\nArgument:\n\nrho_u0 rho_v0: initial condition rho_0 = rho_u0 - i rho_v0\nLK: real part of the Hamiltonian operator\nLS: imaginary part of the Hamiltonain operator\nLD: Lindblad operator\ntime: final time or time beining evaluated\ninitial_type: specify initial value is a density matrix/a state vector\n\nOutput:\n\nA problem object which we will feed to DifferentialEquations.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.LindbladODEProblemComplex-Tuple{Any,Array{Complex{Float64},2},Float64}","page":"Methods","title":"GLOQ.LindbladODEProblemComplex","text":"LindbladODEProblemComplex(rho0,L::Array{ComplexF64,2},time_final::Float64;initial_type = \"density\")\n\nFunction provide interfaces to DifferentialEquations package to solve: rho_t = L rho\n\nArgument:\n\nL: Lindblad operator\ntime: final time or time beining evaluated\nrho0: initial condition\ninitial_type: specify initial value is a density matrix/a state vector\n\nOutput:\n\nA complex-valued problem object which we will feed to DifferentialEquations.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RamseyForwardSolve","page":"Methods","title":"GLOQ.RamseyForwardSolve","text":"function RamseyForwardSolve(rhou0::Array{Float64},rhov0::Array{Float64}, \t\t\t\t\t\t  omega::Array{Float64},omegadrive::Float64, \t\t\t\t\t\t  gamma1::Array{Float64},gamma2::Array{Float64}, \t\t\t\t\t\t  InitialState::Int64, \t\t\t\t\t\t  TC::Float64,tdarktimes::Array{Float64}, \t\t\t\t\t\t  Nstates::Int64=0; \t\t\t\t\t\t  initial_type=\"states\", \t\t\t\t\t\t  method=\"exponential\", \t\t\t\t\t\t  DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nOutput:\n\nrhoramseyu,rhoramseyv: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.RamseyParityForwardSolve","page":"Methods","title":"GLOQ.RamseyParityForwardSolve","text":"RamseyParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive:Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitalState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;initial_type=\"states\")\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n\"exponential\": exponential time integrator\n\"DiffEqDefault\": a default choice made by DifferentialEquations.jl\nOther solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrhoramseyu,rhoramseyv: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.RotationFrameDiagonal-Tuple{Array{Float64,N} where N,Float64}","page":"Methods","title":"GLOQ.RotationFrameDiagonal","text":"RotationFrameDiagonal(omega::Array{Float64},omega_drive::Float64)\n\nArgument:\n\nomega: transition frequencies\nomega_drive: driving frequency\nN: number of states\n\nOutput:\n\nDiagonal matrix diag{0,omega[1]-omr,omega[2]-omr,...,omega[N-1]-omr}\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameLindblad-Tuple{Array{Float64,N} where N,Array{Float64,N} where N}","page":"Methods","title":"GLOQ.RotationFrameLindblad","text":"RotationFrameDiagonal(gamma1::Array{Float64},gamma2::Array{Float64})\n\nArgument:\n\ngamma1: determine the decay operator in the Lindblad system\ngamma2: determine the dephasing operator in the Lindblad system\n\nOutput:\n\nLdecay: Ldecay[i][i+1] = sqrt(gamma1[i]), and zeros everywhere else\nL_dephase: Diagonal{0,sqrt(gamma2[1]),...)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameRamseyControl-Tuple{Float64,Float64,Int64}","page":"Methods","title":"GLOQ.RotationFrameRamseyControl","text":"RotationFrameRamseyControl(abs_control::Float64,phase_control::Float64,N::Int64)\n\nArgument:\n\nabs_control: strength of the control Omega\nphase_control: phase of the control signal theta\nN: number of states\n\nOutput:\n\nHCK,HCS: the real and imaginary part of the control operator, determined by p(a+a^dagger)+iq(a-a^dagger) where a is the lowering operator, p=Omegacos(theta) and q=Omegasin(theta)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.RotationFrameRamseyControl-Tuple{Int64}","page":"Methods","title":"GLOQ.RotationFrameRamseyControl","text":"RotationFrameRamseyControl(N::Int64)\n\nArgument:\n\nabs_control: strength of the control Omega\nphase_control: phase of the control signal theta\nN: number of states\n\nOutput:\n\nHCK,HCS: the real and imaginary part of the control operator, determined by (a+a^dagger)\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.T1ForwardSolve","page":"Methods","title":"GLOQ.T1ForwardSolve","text":"T1ForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\n\nOutput:\n\nrhoechou,rhoechov: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.T1ParityForwardSolve","page":"Methods","title":"GLOQ.T1ParityForwardSolve","text":"T1ParityForwardSolve(rho_u0::Array{Float64},rho_v0::Array{Float64},\n\t\t\t\t   omega::Array{Float64},omega_drive::Float64,\n\t\t\t\t   charge_noise::Array{Float64},\n\t\t\t\t   gamma1::Array{Float64},gamma2::Array{Float64},\n\t\t\t\t   InitialState::Int64,\n\t\t\t\t   TC::Float64,t_dark_times::Array{Float64},\n\t\t\t\t   N_states::Int64=0;\n\t\t\t\t   initial_type=\"states\",\n\t\t\t\t   method=\"exponential\",\n\t\t\t\t   DiffEqKwargs...)\n\nArgument:\n\nrhou0,rhov0: initial states rho_u_0-irho_v_0\nomega: transition frequencies\nomega_drive: driving frequency\ncharge_noise: charge noise\ngamma1,gamma2: determine the decay part and the dephasing part of the Lindblad operators\nInitialState: initial state of the density matrix\nTC: control time of the control signal\ntdarktimes: the dark time in the Ramsey experiment\nN_states: number of states\nInitialState: initial state of the density matrix\nmethod: method to solve the Lindblad system\n\n- \"exponential\": exponential time integrator\n- \"DiffEqDefault\": a default choice made by DifferentialEquations.jl\n- Other solvers availabe in DifferentialEquations.jl, for example, method = Trapezoid()\n\nDiffEqKwargs: keyword arguments feed to the ``solve function\" of DifferentialEquations.jl\n\nParity event\n\nTransition frequency will take equal probability to be omegapm0.5timescharge_noise\n\nOutput:\n\nrhoechou,rhoechov: density matrix at dark times, with rho=rho_u-irho_v\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.about-Tuple{}","page":"Methods","title":"GLOQ.about","text":"About GLOQ.jl\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.convert_state_to_density-Tuple{Array{Float64,1},Array{Float64,1}}","page":"Methods","title":"GLOQ.convert_state_to_density","text":"convert_state_to_density(u::Array{Float64,1},v::Array{Float64,1})\n\nArgument:\n\nstate vector: u-iv\n\nOutput:\n\nvectorized density matrix: rhou-i rhov\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.exponential_solver","page":"Methods","title":"GLOQ.exponential_solver","text":"exponential_solver_complex(rho_vec0,L,t_span::Array{Float64};initial_type = \"density\"):\n\nPurpose:\n\nuse an exponential integrator to integrate\nrho_t=-i(L_K+iL_S) rho+L_D  ho\n\nArgument:\n\nrho_u0rho_v0: rho0 =\\rho{u0} - i \\rho{v0}``\nLK: real part of the Hamiltonian operator\nLS: imaginary part of the Hamiltonain operator\nLD: Lindblad operator\nt_span: where the solution will be stored\ninitial_type: \"density\" vectorized density matrix, \"states\" states vector\n\nOutput:\n\nrhou,rhov: solutions at tspan given by ``\\rho(ti) =  hou(:,i)-i  hov(:,i)``\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.exponential_solver_complex-Tuple{Any,Any,Array{Float64,N} where N}","page":"Methods","title":"GLOQ.exponential_solver_complex","text":"exponential_solver_complex(rho_vec0,L,t_span::Array{Float64};initial_type = \"density\"):\n\nArgument:\n\nL: the whole propagation operator\nt_span: where the function will be evaluated stored in\nrho0_vec: initial density/state\ninitial_type: decide we aer given an initial density matrix or a state vector\n\nOutput:\n\nsolutions at t_span\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.exponential_solver_complex-Tuple{Any,Any,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}","page":"Methods","title":"GLOQ.exponential_solver_complex","text":"exponential_solver(rho_vec0,L,t_span::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}};\n                   initial_type = \"density\")\n\nArgument:\n\nL: the whole propagation operator\nt_span: where the function will be evaluated stored in\nrho0_vec: initial density/state\ninitial_type: decide we aer given an initial density matrix or a state vector\n\nOutput:\n\nComplex-valued solutions at t_span\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Complex{Float64},1}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(rho_vec::Array{ComplexF64,1})\n\nArgument:\n\nrho_vec, density matrix in the vector form\n\nOutput:\n\nthe population in an array\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Complex{Float64},2}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(rho_vec_history::Array{ComplexF64,2})\n\nArgument:\n\nrhovechistory, time history for the vectorized density matrix,\n\ni-th column corresponding to the i-th time point\n\nOutput:\n\nThe population history P which is a 2D array, P[i,j] is corresponding\n\nto time point i and state j\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.get_population-Tuple{Array{Float64,2}}","page":"Methods","title":"GLOQ.get_population","text":"get_population(rho_vec_history::Array{Float64,2})\n\nArgument:\n\nrhouhistory: time history for the vectorized density matrix, j-th column corresponding to the j-th time point\n\nrhohistory = rhouhistory - i rhov_history.\n\nSince the density matrix should be Hermitian, it is good enough to just have the real part.\n\nOutput:\n\nThe population history P which is a 2D array, P[i,j] is corresponding\n\nto time point i and state j\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.hello_world-Tuple{}","page":"Methods","title":"GLOQ.hello_world","text":"hello_world():\n\nA hello world function\n\n\n\n\n\n","category":"method"},{"location":"methods/#GLOQ.make_hamiltonian_operator","page":"Methods","title":"GLOQ.make_hamiltonian_operator","text":"make_Hamiltonian_operator(HK,HS,N::Int64=0)\n\nArgument:\n\nThe real part and the imaginary part of the Hamiltonian: H = H_K-i H_S\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLK: real matrix corresponding to the real part of the Hamiltonian operator\nLS: real matrix corresponding to the imaginary part of the Hamiltonian operator\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.make_lindblad_operator","page":"Methods","title":"GLOQ.make_lindblad_operator","text":"make_lindblad_operator(HK,HS,L_list,N::Int64=0)\n\nArgument:\n\nThe real part and the imaginary part of the Hamiltonian: H = H_K-i H_S\nA list of Lindblad terms L_k's\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLK: real matrix corresponding to the real part of the Hamiltonian operator\nLS: real matrix corresponding to the imaginary part of the Hamiltonian operator\nLD: real matrix corresponding to the Lindblad operator\nFinal system: rho_t = -i(L_K+i L_S)rho+L_D rho\n\n\n\n\n\n","category":"function"},{"location":"methods/#GLOQ.make_lindblad_operator_complex","page":"Methods","title":"GLOQ.make_lindblad_operator_complex","text":"make_lindblad_operator(H,L_list,N::Int64=0)\n\nArgument:\n\nthe Hamiltonain H and a list of Lindblad terms L_k's\nN is number of states\n\nOutput:\n\nthe operator for the vectorized system\n\nLH: complex matrix corresponding to the Hamiltonian operator\nLD: complex matrix corresponding to the Lindblad operator\n\n\n\n\n\n","category":"function"},{"location":"#GLOQ.jl","page":"Home","title":"GLOQ.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GLOQ.jl","category":"page"},{"location":"function-index/","page":"Index","title":"Index","text":"Modules = [GLOQ]","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The following types are exported and available by using GLOQ.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [GLOQ]\nOrder = [:type]","category":"page"}]
}
